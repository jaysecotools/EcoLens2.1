Looking at your code and the exported CSV, I can identify the main issue. The CSV export contains metadata lines at the beginning (starting with Export Metadata:), which makes the CSV invalid for re-import because the import function expects a standard CSV format with headers in the first row.

Here's the fix. Update the exportToCSV function to export a clean CSV without metadata when exporting for re-import purposes:

Replace the current exportToCSV function (around line 2418) with this improved version:

```javascript
// Export to CSV with all fields and metadata
exportToCSV(observations, dateFrom, dateTo, selectedIds) {
    const headers = [
        'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
        'Latitude', 'Longitude', 'Habitat', 'Observation Type',
        'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
    ];
    
    // Create clean data rows without metadata for import compatibility
    const rows = observations.map(obs => {
        // Format timestamp for CSV import compatibility
        const timestamp = new Date(obs.timestamp);
        const formattedTimestamp = timestamp.toISOString(); // Use ISO format for import compatibility
        
        // Extract coordinates if available
        const lat = obs.location.coordinates?.lat || '';
        const lng = obs.location.coordinates?.lng || '';
        
        // Format location text - clean up the "Lat: X, Lng: Y" format if it's a coordinate string
        let locationText = obs.location.text;
        if (locationText.startsWith('Lat:') && locationText.includes('Lng:')) {
            // Keep the coordinate string as is for location field
        }
        
        return [
            `"${this.sanitizeCSVValue(obs.id)}"`,
            `"${formattedTimestamp}"`, // Use ISO format for consistent import
            `"${this.sanitizeCSVValue(obs.observerName)}"`,
            `"${this.sanitizeCSVValue(obs.scientificName)}"`,
            `"${this.sanitizeCSVValue(obs.commonName)}"`,
            `"${this.sanitizeCSVValue(locationText)}"`,
            lat ? `"${lat}"` : '',
            lng ? `"${lng}"` : '',
            `"${this.sanitizeCSVValue(obs.habitat)}"`,
            `"${this.sanitizeCSVValue(obs.observationType)}"`,
            `"${this.sanitizeCSVValue(obs.characteristics || '')}"`,
            `"${this.sanitizeCSVValue((obs.equipment || []).join('; '))}"`,
            `"${this.sanitizeCSVValue(obs.references || '')}"`,
            `"${this.sanitizeCSVValue(obs.notes || '')}"`,
            obs.photo ? 'Yes' : 'No'
        ];
    });
    
    // Create CSV content - start with headers only for import compatibility
    const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    
    const filename = selectedIds ? 
        `EcoLens_Selected_Export_${new Date().toISOString().slice(0,10)}.csv` :
        `EcoLens_Export_${new Date().toISOString().slice(0,10)}.csv`;
    
    this.showExportDownload(url, filename);
    this.showStatus(`Exported ${observations.length} observations to CSV`, 'success', 'export');
},
```

Additionally, you should add a separate function to export with metadata for human-readable exports, and modify the export handling:

Add this function for metadata exports:

```javascript
// Export to CSV with metadata (for human-readable exports)
exportToCSVWithMetadata(observations, dateFrom, dateTo, selectedIds) {
    const headers = [
        'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
        'Latitude', 'Longitude', 'Habitat', 'Observation Type',
        'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
    ];
    
    // Create metadata header
    const metadata = [
        `Export Metadata:`,
        `Exported: ${new Date().toLocaleString()}`,
        `Total Observations: ${observations.length}`,
        `Date Range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`,
        `Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`,
        `Exported by: ${observations[0]?.observerName || 'EcoLens User'}`,
        `App Version: 1.0`,
        ``
    ];
    
    const rows = observations.map(obs => {
        const timestamp = new Date(obs.timestamp);
        const lat = obs.location.coordinates?.lat || '';
        const lng = obs.location.coordinates?.lng || '';
        
        return [
            `"${this.sanitizeCSVValue(obs.id)}"`,
            `"${timestamp.toLocaleString()}"`, // Human readable format
            `"${this.sanitizeCSVValue(obs.observerName)}"`,
            `"${this.sanitizeCSVValue(obs.scientificName)}"`,
            `"${this.sanitizeCSVValue(obs.commonName)}"`,
            `"${this.sanitizeCSVValue(obs.location.text)}"`,
            lat,
            lng,
            `"${this.sanitizeCSVValue(obs.habitat)}"`,
            `"${this.sanitizeCSVValue(obs.observationType)}"`,
            `"${this.sanitizeCSVValue(obs.characteristics || '')}"`,
            `"${this.sanitizeCSVValue((obs.equipment || []).join('; '))}"`,
            `"${this.sanitizeCSVValue(obs.references || '')}"`,
            `"${this.sanitizeCSVValue(obs.notes || '')}"`,
            obs.photo ? 'Yes' : 'No'
        ];
    });
    
    const csvContent = [
        ...metadata,
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');
    
    return csvContent;
},
```

Update the handleExport function to offer both options:

Replace the handleExport function (around line 2083) with:

```javascript
// Handle export generation
handleExport() {
    const format = document.querySelector('input[name="export-format"]:checked').value;
    const dateFrom = document.getElementById('date-from').value;
    const dateTo = document.getElementById('date-to').value;
    const enableBatch = document.getElementById('enable-batch-selection').checked;
    
    // Get selected observation IDs if batch selection is enabled
    const selectedIds = enableBatch && this.selectedObservations.size > 0 ? this.selectedObservations : null;
    
    const filteredObservations = this.getFilteredObservations(dateFrom, dateTo, selectedIds);
    
    if (filteredObservations.length === 0) {
        this.showStatus('No observations found for the selected criteria', 'error', 'export');
        return;
    }
    
    if (format === 'csv') {
        // Ask user what type of CSV they want
        if (confirm('Do you want to export a CSV that can be re-imported later?\n\nClick "OK" for import-friendly CSV (no metadata, ISO dates).\nClick "Cancel" for human-readable CSV (with metadata).')) {
            this.exportToCSV(filteredObservations, dateFrom, dateTo, selectedIds);
        } else {
            const csvContent = this.exportToCSVWithMetadata(filteredObservations, dateFrom, dateTo, selectedIds);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const filename = selectedIds ? 
                `EcoLens_Selected_Export_With_Metadata_${new Date().toISOString().slice(0,10)}.csv` :
                `EcoLens_Export_With_Metadata_${new Date().toISOString().slice(0,10)}.csv`;
            
            this.showExportDownload(url, filename);
            this.showStatus(`Exported ${filteredObservations.length} observations to CSV (with metadata)`, 'success', 'export');
        }
    } else {
        this.exportToPDF(filteredObservations, dateFrom, dateTo, selectedIds);
    }
},
```

Also, update the CSV template download to use ISO format:

In the downloadCSVTemplate function (around line 2027), change the timestamp example to ISO format:

```javascript
const exampleRow = [
    'ECO-20231225-ABC12',
    '2023-12-25T14:30:00', // ISO format - IMPORTANT for import compatibility
    'Jane Doe',
    'Canis lupus',
    'Gray Wolf',
    'Yellowstone National Park, Wyoming',
    '44.4280',
    '-110.5885',
    'forest',
    'direct',
    'Large adult, gray coat, observed hunting',
    'binoculars; camera',
    'Field Guide to North American Mammals',
    'Observed from 100m distance',
    'No'
];
```

Key changes made:

1. Removed metadata lines from the import-friendly CSV export
2. Used ISO date format (YYYY-MM-DDTHH:mm:ss) for timestamps instead of locale-specific formats
3. Properly quoted all fields to handle commas in text
4. Added a prompt to let users choose between import-friendly and human-readable CSV
5. Fixed the template to show ISO format dates

The main issue was that the exported CSV had metadata lines at the beginning and used human-readable date formats that weren't consistently parsed by the import function. The import function expects:

· A clean CSV starting with headers
· ISO format dates for reliable parsing
· No extra metadata lines

With these changes, the exported CSV should now be importable back into the app.
