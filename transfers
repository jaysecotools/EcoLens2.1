// Export to CSV with all fields and metadata
exportToCSV(observations, dateFrom, dateTo, selectedIds) {
    const headers = [
        'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
        'Latitude', 'Longitude', 'Habitat', 'Observation Type',
        'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
    ];
    
    // Create clean data rows without metadata for import compatibility
    const rows = observations.map(obs => {
        // Format timestamp for CSV import compatibility
        const timestamp = new Date(obs.timestamp);
        const formattedTimestamp = timestamp.toISOString(); // Use ISO format for import compatibility
        
        // Extract coordinates if available
        const lat = obs.location.coordinates?.lat || '';
        const lng = obs.location.coordinates?.lng || '';
        
        // Format location text - clean up the "Lat: X, Lng: Y" format if it's a coordinate string
        let locationText = obs.location.text;
        if (locationText.startsWith('Lat:') && locationText.includes('Lng:')) {
            // Keep the coordinate string as is for location field
        }
        
        return [
            `"${this.sanitizeCSVValue(obs.id)}"`,
            `"${formattedTimestamp}"`, // Use ISO format for consistent import
            `"${this.sanitizeCSVValue(obs.observerName)}"`,
            `"${this.sanitizeCSVValue(obs.scientificName)}"`,
            `"${this.sanitizeCSVValue(obs.commonName)}"`,
            `"${this.sanitizeCSVValue(locationText)}"`,
            lat ? `"${lat}"` : '',
            lng ? `"${lng}"` : '',
            `"${this.sanitizeCSVValue(obs.habitat)}"`,
            `"${this.sanitizeCSVValue(obs.observationType)}"`,
            `"${this.sanitizeCSVValue(obs.characteristics || '')}"`,
            `"${this.sanitizeCSVValue((obs.equipment || []).join('; '))}"`,
            `"${this.sanitizeCSVValue(obs.references || '')}"`,
            `"${this.sanitizeCSVValue(obs.notes || '')}"`,
            obs.photo ? 'Yes' : 'No'
        ];
    });
    
    // Create CSV content - start with headers only for import compatibility
    const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    
    const filename = selectedIds ? 
        `EcoLens_Selected_Export_${new Date().toISOString().slice(0,10)}.csv` :
        `EcoLens_Export_${new Date().toISOString().slice(0,10)}.csv`;
    
    this.showExportDownload(url, filename);
    this.showStatus(`Exported ${observations.length} observations to CSV`, 'success', 'export');
}, // <-- This closes the exportToCSV function

// Export to CSV with metadata (for human-readable exports) - MOVED OUTSIDE
exportToCSVWithMetadata(observations, dateFrom, dateTo, selectedIds) {
    const headers = [
        'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
        'Latitude', 'Longitude', 'Habitat', 'Observation Type',
        'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
    ];
    
    // Create metadata header
    const metadata = [
        `Export Metadata:`,
        `Exported: ${new Date().toLocaleString()}`,
        `Total Observations: ${observations.length}`,
        `Date Range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`,
        `Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`,
        `Exported by: ${observations[0]?.observerName || 'EcoLens User'}`,
        `App Version: 1.0`,
        ``
    ];
    
    const rows = observations.map(obs => {
        const timestamp = new Date(obs.timestamp);
        const lat = obs.location.coordinates?.lat || '';
        const lng = obs.location.coordinates?.lng || '';
        
        return [
            `"${this.sanitizeCSVValue(obs.id)}"`,
            `"${timestamp.toLocaleString()}"`, // Human readable format
            `"${this.sanitizeCSVValue(obs.observerName)}"`,
            `"${this.sanitizeCSVValue(obs.scientificName)}"`,
            `"${this.sanitizeCSVValue(obs.commonName)}"`,
            `"${this.sanitizeCSVValue(obs.location.text)}"`,
            lat,
            lng,
            `"${this.sanitizeCSVValue(obs.habitat)}"`,
            `"${this.sanitizeCSVValue(obs.observationType)}"`,
            `"${this.sanitizeCSVValue(obs.characteristics || '')}"`,
            `"${this.sanitizeCSVValue((obs.equipment || []).join('; '))}"`,
            `"${this.sanitizeCSVValue(obs.references || '')}"`,
            `"${this.sanitizeCSVValue(obs.notes || '')}"`,
            obs.photo ? 'Yes' : 'No'
        ];
    });
    
    const csvContent = [
        ...metadata,
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');
    
    return csvContent;
},
    
    // Create CSV content
    const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    
    const filename = selectedIds ? 
        `EcoLens_Selected_Export_${new Date().toISOString().slice(0,10)}.csv` :
        `EcoLens_Export_${new Date().toISOString().slice(0,10)}.csv`;
    
    this.showExportDownload(url, filename);
    this.showStatus(`Exported ${observations.length} observations to CSV`, 'success', 'export');
},
