<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoLens - Field Observation Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    /* CSS Reset & Base Styles */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }

    /* Light mode variables (default) */
    :root {
        --primary: #2e8b57;
        --primary-dark: #1e6b47;
        --primary-light: #e8f5e9;
        --secondary: #3498db;
        --secondary-dark: #2980b9;
        --accent: #f39c12;
        --dark: #2c3e50;
        --dark-light: #34495e;
        --light: #f8f9fa;
        --light-gray: #ecf0f1;
        --medium-gray: #bdc3c7;
        --danger: #e74c3c;
        --success: #27ae60;
        --warning: #f39c12;
        --info: #3498db;
        --border-radius: 12px;
        --border-radius-sm: 8px;
        --border-radius-lg: 16px;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
        --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        --transition-fast: all 0.2s ease;
        
        /* Light mode color variables */
        --bg-primary: #f8f9fa;
        --bg-secondary: white;
        --text-primary: #333;
        --text-secondary: #2c3e50;
        --border-color: #ecf0f1;
        --shadow-color: rgba(0, 0, 0, 0.08);
    }

    /* Dark mode variables */
    body.dark-mode {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --text-primary: #e0e0e0;
        --text-secondary: #b0b0b0;
        --border-color: #404040;
        --shadow-color: rgba(0, 0, 0, 0.3);
        --light: #2d2d2d;
        --light-gray: #404040;
        --medium-gray: #666;
    }

    body {
        font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        color: var(--text-primary);
        background: var(--bg-primary);
        max-width: 100vw;
        min-height: 100vh;
        overflow-x: hidden;
        transition: background-color 0.3s ease, color 0.3s ease;
    }

    /* Header & Navigation */
    .header {
        background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
        color: white;
        padding: 1rem 1.5rem;
        position: sticky;
        top: 0;
        z-index: 1000;
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        background-color: rgba(44, 62, 80, 0.95);
    }

    .app-title-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 1rem;
    }

    .app-icon {
        font-size: 1.8rem;
        color: var(--primary-light);
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    }

    .app-title {
        font-size: 1.8rem;
        font-weight: 700;
        text-align: center;
        background: linear-gradient(90deg, #fff, var(--primary-light));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -0.5px;
    }

    .app-subtitle {
        font-size: 0.9rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.8);
        margin-top: -5px;
        font-weight: 400;
    }

    .nav-tabs {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        background: rgba(0, 0, 0, 0.1);
        padding: 0.5rem;
        border-radius: var(--border-radius);
        max-width: 600px;
        margin: 0 auto;
    }

    .tab-btn {
        padding: 0.7rem 1.5rem;
        background: transparent;
        border: none;
        border-radius: var(--border-radius);
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition-fast);
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
    }

    .tab-btn.active {
        background: rgba(255, 255, 255, 0.15);
        color: white;
        font-weight: 600;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .tab-btn.active::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 60%;
        height: 3px;
        background: var(--primary);
        border-radius: 3px;
    }

    .tab-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.05);
        color: white;
        transform: translateY(-1px);
    }

    /* Main Content */
    .main-content {
        max-width: 900px;
        margin: 0 auto;
        padding: 1.5rem 1rem 3rem;
    }

    .tab-panel {
        display: none;
        animation: fadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    .tab-panel.active {
        display: block;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(15px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
        from { opacity: 0; transform: translateX(-10px); }
        to { opacity: 1; transform: translateX(0); }
    }

    /* Form Styles */
    .form-section {
        background: var(--bg-secondary);
        border-radius: var(--border-radius-lg);
        padding: 2rem;
        margin-bottom: 1.5rem;
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: var(--transition);
    }

    .form-section:hover {
        box-shadow: var(--shadow-lg);
    }

    .form-title {
        font-size: 1.4rem;
        margin-bottom: 1.5rem;
        color: var(--dark);
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--light-gray);
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
    }

    body.dark-mode .form-title {
        color: var(--text-primary);
    }

    .form-title i {
        color: var(--primary);
    }

    .form-group {
        margin-bottom: 1.8rem;
        animation: slideIn 0.3s ease-out;
    }

    .form-label {
        display: block;
        font-weight: 600;
        margin-bottom: 0.6rem;
        color: var(--dark-light);
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    body.dark-mode .form-label {
        color: var(--text-primary);
    }

    .form-label.required::after {
        content: " *";
        color: var(--danger);
    }

    .form-input,
    .form-select,
    .form-textarea {
        width: 100%;
        padding: 0.9rem 1rem;
        border: 2px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        font-size: 1rem;
        transition: var(--transition-fast);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
    }

    .form-input:focus,
    .form-select:focus,
    .form-textarea:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(46, 139, 87, 0.15);
    }

    .form-textarea {
        min-height: 120px;
        resize: vertical;
        line-height: 1.5;
    }

    .form-row {
        display: flex;
        gap: 1.5rem;
        margin-bottom: 1.8rem;
    }

    .form-col {
        flex: 1;
    }

    /* Map Container */
    #map-container {
        height: 320px;
        margin-top: 1rem;
        border-radius: var(--border-radius-sm);
        overflow: hidden;
        border: 2px solid var(--light-gray);
        box-shadow: var(--shadow-sm);
        display: none;
        position: relative;
    }

    #map {
        height: 100%;
        width: 100%;
    }

    .map-controls {
        display: flex;
        gap: 0.75rem;
        margin-top: 1rem;
        flex-wrap: wrap;
    }

    /* Button Styles */
    .btn {
        padding: 0.85rem 1.75rem;
        border: none;
        border-radius: var(--border-radius);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        position: relative;
        overflow: hidden;
    }

    .btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 5px;
        height: 5px;
        background: rgba(255, 255, 255, 0.5);
        opacity: 0;
        border-radius: 100%;
        transform: scale(1, 1) translate(-50%);
        transform-origin: 50% 50%;
    }

    .btn:focus:not(:active)::after {
        animation: ripple 1s ease-out;
    }

    @keyframes ripple {
        0% {
            transform: scale(0, 0);
            opacity: 0.5;
        }
        100% {
            transform: scale(40, 40);
            opacity: 0;
        }
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(46, 139, 87, 0.25);
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, var(--primary-dark) 0%, #165a36 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(46, 139, 87, 0.35);
    }

    .btn-secondary {
        background: linear-gradient(135deg, var(--secondary) 0%, var(--secondary-dark) 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.25);
    }

    .btn-secondary:hover {
        background: linear-gradient(135deg, var(--secondary-dark) 0%, #21618c 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(52, 152, 219, 0.35);
    }

    .btn-outline {
        background: white;
        color: var(--primary);
        border: 2px solid var(--primary);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .btn-outline {
        background: var(--bg-secondary);
        color: var(--primary-light);
        border-color: var(--primary);
    }

    .btn-outline:hover {
        background: var(--primary-light);
        color: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .btn-outline:hover {
        background: var(--primary);
        color: white;
    }

    .btn-danger {
        background: linear-gradient(135deg, var(--danger) 0%, #c0392b 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.25);
    }

    .btn-danger:hover {
        background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(231, 76, 60, 0.35);
    }

    .btn-small {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        border-radius: var(--border-radius-sm);
    }

    .btn-block {
        width: 100%;
        padding: 1rem;
        font-size: 1.05rem;
    }

    .btn-group {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.5rem;
        flex-wrap: wrap;
    }

    /* Photo Upload */
    .photo-container {
        margin-top: 1rem;
    }

    .photo-preview-container {
        position: relative;
        display: inline-block;
        margin-top: 1rem;
    }

    .photo-preview {
        max-width: 250px;
        max-height: 250px;
        border-radius: var(--border-radius);
        border: 2px solid var(--light-gray);
        display: none;
        box-shadow: var(--shadow);
        transition: var(--transition);
    }

    .photo-preview:hover {
        transform: scale(1.02);
        box-shadow: var(--shadow-lg);
    }

    .photo-remove {
        position: absolute;
        top: -10px;
        right: -10px;
        background: var(--danger);
        color: white;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 2px solid white;
        box-shadow: var(--shadow);
        font-size: 0.9rem;
        z-index: 10;
    }

    /* Checkbox/Radio Groups */
    .checkbox-group,
    .radio-group {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 0.75rem;
    }

    .checkbox-item,
    .radio-item {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        padding: 0.5rem 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        transition: var(--transition-fast);
        cursor: pointer;
    }

    body.dark-mode .checkbox-item,
    body.dark-mode .radio-item {
        background: var(--light);
        color: var(--text-primary);
    }

    .checkbox-item:hover,
    .radio-item:hover {
        background: var(--primary-light);
        transform: translateY(-2px);
    }

    body.dark-mode .checkbox-item:hover,
    body.dark-mode .radio-item:hover {
        background: var(--primary);
    }

    .checkbox-item input[type="checkbox"],
    .radio-item input[type="radio"] {
        width: auto;
        accent-color: var(--primary);
    }

    /* DateTime Input */
    .datetime-inputs {
        display: flex;
        gap: 1rem;
        align-items: flex-end;
    }

    .datetime-inputs input {
        flex: 1;
    }

    .datetime-now-btn {
        white-space: nowrap;
        height: 100%;
        padding: 0.9rem 1.5rem;
    }

    /* Logbook Styles */
    .logbook-entries {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
    }

    .log-entry {
        background: white;
        border-radius: var(--border-radius);
        padding: 1.5rem;
        box-shadow: var(--shadow-sm);
        cursor: pointer;
        transition: var(--transition);
        border-left: 4px solid var(--primary);
        position: relative;
        overflow: hidden;
    }

    body.dark-mode .log-entry {
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    .log-entry:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-lg);
    }

    .log-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 0.75rem;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .log-id {
        font-family: 'Courier New', monospace;
        color: var(--medium-gray);
        font-size: 0.85rem;
        background: var(--light);
        padding: 0.25rem 0.75rem;
        border-radius: 20px;
        font-weight: 500;
    }

    .log-date {
        color: var(--medium-gray);
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .log-species {
        font-weight: 700;
        font-size: 1.2rem;
        color: var(--dark);
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    body.dark-mode .log-species {
        color: var(--text-primary);
    }

    .log-species::before {
        content: "ü¶ã";
        font-size: 1.1rem;
    }

    .log-location {
        color: var(--dark-light);
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 0.5rem;
    }

    .log-location::before {
        content: "üìç";
        font-size: 0.9rem;
    }

    .log-details {
        margin-top: 1.2rem;
        padding-top: 1.2rem;
        border-top: 1px solid var(--light-gray);
        display: none;
        animation: fadeIn 0.3s ease;
    }

    .log-details.show {
        display: block;
    }

    .log-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.2rem;
    }

    /* Export Panel */
    .export-options {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.8rem;
        margin-bottom: 1.5rem;
        box-shadow: var(--shadow);
    }

    .export-option-group {
        margin-bottom: 2rem;
    }

    .export-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
        padding: 0.75rem 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        transition: var(--transition-fast);
    }

    body.dark-mode .export-option {
        background: var(--light);
        color: var(--text-primary);
    }

    .export-option:hover {
        background: var(--primary-light);
    }

    .export-option input[type="radio"] {
        width: auto;
        accent-color: var(--primary);
    }

    .date-range {
        display: flex;
        gap: 1.5rem;
        margin-top: 1rem;
    }

    .date-input {
        flex: 1;
    }

    /* Import Section */
    .import-section {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.8rem;
        margin-bottom: 1.5rem;
        border: 2px dashed var(--secondary);
        background: linear-gradient(135deg, var(--light) 0%, var(--light-gray) 100%);
        box-shadow: var(--shadow);
    }

    body.dark-mode .import-section {
        background: linear-gradient(135deg, var(--light) 0%, var(--dark-light) 100%);
    }

    .import-options {
        margin-top: 1rem;
    }

    .import-note {
        font-size: 0.9rem;
        color: var(--dark-light);
        margin-top: 1rem;
        padding: 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        border-left: 4px solid var(--secondary);
        line-height: 1.5;
    }

    body.dark-mode .import-note {
        background: var(--light);
        color: var(--text-primary);
    }

    /* Import Mode Selection */
    .import-mode {
        display: flex;
        gap: 1.5rem;
        margin-top: 1.2rem;
        flex-wrap: wrap;
    }

    .import-mode-option {
        flex: 1;
        min-width: 200px;
    }

    /* CSV Preview & Validation */
    .csv-preview-section {
        margin-top: 1.5rem;
        display: none;
        animation: fadeIn 0.4s ease;
    }

    .csv-preview-table {
        width: 100%;
        border-collapse: collapse;
        margin: 1rem 0;
        font-size: 0.9rem;
        box-shadow: var(--shadow-sm);
        border-radius: var(--border-radius-sm);
        overflow: hidden;
    }

    .csv-preview-table th,
    .csv-preview-table td {
        padding: 0.75rem;
        border: 1px solid var(--light-gray);
        text-align: left;
    }

    .csv-preview-table th {
        background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
        color: white;
        font-weight: 600;
        position: sticky;
        top: 0;
    }

    .csv-preview-table .error-row {
        background-color: #f8d7da;
    }

    .csv-preview-table .warning-row {
        background-color: #fff3cd;
    }

    .validation-summary {
        padding: 1.2rem;
        border-radius: var(--border-radius);
        margin: 1rem 0;
    }

    .validation-errors {
        margin-top: 0.75rem;
    }

    .validation-error {
        padding: 0.75rem;
        background: #f8d7da;
        border-radius: var(--border-radius-sm);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        border-left: 4px solid var(--danger);
    }

    .validation-warning {
        padding: 0.75rem;
        background: #fff3cd;
        border-radius: var(--border-radius-sm);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        border-left: 4px solid var(--warning);
    }

    .validation-stats {
        display: flex;
        gap: 1.5rem;
        margin: 1.5rem 0;
        flex-wrap: wrap;
    }

    .stat-item {
        padding: 0.75rem 1.25rem;
        border-radius: var(--border-radius);
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: var(--shadow-sm);
    }

    .stat-valid {
        background: #d5edda;
        color: #155724;
    }

    .stat-invalid {
        background: #f8d7da;
        color: #721c24;
    }

    .stat-warning {
        background: #fff3cd;
        color: #856404;
    }

    /* Status Messages */
    .status-message {
        padding: 1.2rem;
        border-radius: var(--border-radius);
        margin: 1.5rem 0;
        text-align: center;
        font-weight: 500;
        animation: fadeIn 0.3s ease;
        box-shadow: var(--shadow-sm);
    }

    .status-success {
        background: #d5edda;
        color: #155724;
        border: 1px solid #c3e6cb;
        border-left: 4px solid var(--success);
    }

    .status-error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        border-left: 4px solid var(--danger);
    }

    .status-info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
        border-left: 4px solid var(--info);
    }

    .status-warning {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
        border-left: 4px solid var(--warning);
    }

    body.dark-mode .status-message {
        background: var(--bg-secondary);
    }

    /* Loading Indicator */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* PDF Generation Status */
    .pdf-status {
        background: #e8f4fc;
        border: 1px solid #b6e0fe;
        border-radius: var(--border-radius);
        padding: 1.5rem;
        margin: 1.5rem 0;
        display: none;
        box-shadow: var(--shadow-sm);
    }

    .pdf-status progress {
        width: 100%;
        height: 12px;
        margin: 0.75rem 0;
        border-radius: 6px;
        overflow: hidden;
    }

    .pdf-status progress::-webkit-progress-bar {
        background-color: #f0f0f0;
        border-radius: 6px;
    }

    .pdf-status progress::-webkit-progress-value {
        background: linear-gradient(90deg, var(--primary), var(--secondary));
        border-radius: 6px;
    }

    /* Tooltip */
    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltip-text {
        visibility: hidden;
        width: 220px;
        background-color: var(--dark);
        color: white;
        text-align: center;
        border-radius: var(--border-radius-sm);
        padding: 0.75rem;
        position: absolute;
        z-index: 100;
        bottom: 125%;
        left: 50%;
        margin-left: -110px;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.85rem;
        font-weight: normal;
        box-shadow: var(--shadow);
    }

    .tooltip:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
    }

    /* Batch Selection */
    .batch-selection {
        margin: 1.5rem 0;
        padding: 1.5rem;
        background: var(--light);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-sm);
    }

    .batch-checkboxes {
        max-height: 250px;
        overflow-y: auto;
        margin: 1rem 0;
        padding: 1rem;
        background: white;
        border: 1px solid var(--light-gray);
        border-radius: var(--border-radius-sm);
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }

    body.dark-mode .batch-checkboxes {
        background: var(--bg-secondary);
        border-color: var(--border-color);
    }

    .batch-checkbox-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 0;
        transition: var(--transition-fast);
    }

    .batch-checkbox-item:hover {
        background: var(--primary-light);
        padding-left: 0.5rem;
        border-radius: 4px;
    }

    /* Mini Map Preview */
    .mini-map-preview {
        height: 180px;
        width: 100%;
        border-radius: var(--border-radius-sm);
        margin: 0.75rem 0;
        border: 2px solid var(--light-gray);
        box-shadow: var(--shadow-sm);
    }

    .coordinate-validation {
        font-size: 0.85rem;
        margin-top: 0.5rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .coordinate-valid {
        color: var(--success);
    }

    .coordinate-invalid {
        color: var(--danger);
    }

    /* Empty States */
    .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--medium-gray);
    }

    .empty-state i {
        font-size: 3rem;
        margin-bottom: 1rem;
        color: var(--light-gray);
    }

    body.dark-mode .empty-state i {
        color: var(--medium-gray);
    }

    /* Card Enhancements */
    .card {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.5rem;
        box-shadow: var(--shadow);
        margin-bottom: 1.5rem;
        transition: var(--transition);
        border: 1px solid var(--border-color);
    }

    .card:hover {
        box-shadow: var(--shadow-lg);
    }

    /* Mobile Optimizations */
    @media (max-width: 768px) {
        .main-content {
            padding: 1rem 0.75rem 2rem;
        }
        
        .form-section {
            padding: 1.5rem 1rem;
        }
        
        .header {
            padding: 0.75rem 1rem;
        }
        
        .app-title {
            font-size: 1.5rem;
        }
        
        .app-subtitle {
            font-size: 0.8rem;
        }
        
        .tab-btn {
            padding: 0.6rem;
            font-size: 0.85rem;
        }
        
        .tab-btn i {
            font-size: 1rem;
        }
        
        .form-row {
            flex-direction: column;
            gap: 1rem;
        }
        
        .datetime-inputs {
            flex-direction: column;
            gap: 0.75rem;
            align-items: stretch;
        }
        
        .datetime-inputs input {
            width: 100%;
        }
        
        .datetime-now-btn {
            align-self: flex-start;
            width: auto;
        }
        
        .date-range {
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .log-actions {
            flex-direction: column;
        }
        
        .map-controls {
            flex-direction: column;
        }
        
        .btn {
            padding: 0.75rem 1.25rem;
        }
        
        .btn-block {
            padding: 0.9rem;
        }
        
        .btn-group {
            flex-direction: column;
        }
        
        .import-mode {
            flex-direction: column;
        }
        
        .import-mode-option {
            min-width: 100%;
        }
        
        .validation-stats {
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .form-title {
            font-size: 1.2rem;
        }
        
        #map-container {
            height: 250px;
        }
        
        .photo-preview {
            max-width: 100%;
        }
    }

    @media (max-width: 480px) {
        .nav-tabs {
            flex-direction: column;
        }
        
        .tab-btn {
            justify-content: flex-start;
            padding-left: 1rem;
        }
        
        .checkbox-group,
        .radio-group {
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .checkbox-item,
        .radio-item {
            width: 100%;
        }
    }

    /* Print Styles */
    @media print {
        .header,
        .tab-panel:not(.active),
        .btn,
        .map-controls,
        .photo-remove {
            display: none !important;
        }
        
        .form-section,
        .log-entry,
        .export-options {
            box-shadow: none;
            border: 1px solid #ddd;
            break-inside: avoid;
        }
        
        body {
            background: white;
        }
        
        .main-content {
            max-width: 100%;
            padding: 0;
        }
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    ::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-dark);
    }

    body.dark-mode ::-webkit-scrollbar-track {
        background: var(--light-gray);
    }
    
    body.dark-mode ::-webkit-scrollbar-thumb {
        background: var(--primary);
    }

    /* Floating Action Button for Mobile */
    .fab {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        width: 60px;
        height: 60px;
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        box-shadow: var(--shadow-lg);
        z-index: 100;
        cursor: pointer;
        transition: var(--transition);
    }

    .fab:hover {
        transform: scale(1.1);
    }

    @media (max-width: 768px) {
        .fab {
            display: flex;
        }
    }

    /* Divider */
    .divider {
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--light-gray), transparent);
        margin: 1.5rem 0;
        border: none;
    }

    /* Badge */
    .badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        border-radius: 20px;
        background: var(--primary-light);
        color: var(--primary-dark);
    }

    /* Animation for new entries */
    @keyframes highlight {
        0% { background-color: rgba(46, 139, 87, 0.3); }
        100% { background-color: white; }
    }

    .new-entry {
        animation: highlight 2s ease;
    }

    body.dark-mode .new-entry {
        animation: highlight 2s ease;
    }

    body.dark-mode .new-entry {
        0% { background-color: rgba(46, 139, 87, 0.3); }
        100% { background-color: var(--bg-secondary); }
    }

    /* Dark Mode Toggle Button */
    .dark-mode-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        transition: var(--transition);
        z-index: 1001;
    }
    
    .dark-mode-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: rotate(30deg);
    }
    
    body.dark-mode .dark-mode-btn {
        border-color: rgba(255, 255, 255, 0.3);
        color: var(--accent);
    }
    
    body.dark-mode .dark-mode-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    /* Tab buttons dark mode */
    body.dark-mode .tab-btn {
        color: rgba(255, 255, 255, 0.9);
    }
    
    body.dark-mode .tab-btn.active {
        background: rgba(255, 255, 255, 0.2);
    }
    
    body.dark-mode .tab-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.1);
    }
    
    /* Update map controls for dark mode */
    body.dark-mode .leaflet-tile {
        filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
    }
    
    body.dark-mode .leaflet-control {
        filter: invert(1) hue-rotate(180deg);
    }
</style>
</head>
<body>
    <div class="header">
        <div class="app-title-container">
            <div class="app-icon">üî¨</div>
            <div>
                <h1 class="app-title">EcoLens</h1>
                <div class="app-subtitle">Field Observation & Data Collection Tool</div>
            </div>
        </div>

        <button id="dark-mode-toggle" class="dark-mode-btn" title="Toggle dark mode">
            <i class="fas fa-moon"></i>
        </button>

        <div class="nav-tabs">
            <button class="tab-btn active" data-tab="record">
                <i class="fas fa-plus-circle"></i> Record
            </button>
            <button class="tab-btn" data-tab="logbook">
                <i class="fas fa-book"></i> Logbook
            </button>
            <button class="tab-btn" data-tab="export">
                <i class="fas fa-file-export"></i> Export
            </button>
        </div>
    </div>

    <div class="main-content">
        <!-- Record Panel -->
        <div id="record-panel" class="tab-panel active">
            <div class="form-section">
                <h2 class="form-title">
                    <i class="fas fa-feather-alt"></i> New Field Observation
                </h2>
                
                <!-- Date & Time -->
                <div class="form-group">
                    <label class="form-label required" for="observation-date">
                        <i class="far fa-calendar-alt"></i> Observation Date & Time
                    </label>
                    <div class="datetime-inputs">
                        <div class="form-col">
                            <input type="date" id="observation-date" class="form-input" required aria-label="Observation date">
                        </div>
                        <div class="form-col">
                            <input type="time" id="observation-time" class="form-input" required aria-label="Observation time">
                        </div>
                        <button type="button" id="set-now" class="btn btn-outline datetime-now-btn">
                            <i class="far fa-clock"></i> Now
                        </button>
                    </div>
                </div>

                <!-- Observer Name -->
                <div class="form-group">
                    <label class="form-label required" for="observer-name">
                        <i class="fas fa-user"></i> Observer Name
                    </label>
                    <input type="text" id="observer-name" class="form-input" 
                           placeholder="Enter observer's full name" required aria-label="Observer name">
                </div>

                <!-- Species Information -->
                <div class="form-row">
                    <div class="form-col">
                        <label class="form-label required" for="scientific-name">
                            <i class="fas fa-dna"></i> Scientific Name
                        </label>
                        <input type="text" id="scientific-name" class="form-input" 
                               placeholder="Genus species" required aria-label="Scientific name">
                    </div>
                    <div class="form-col">
                        <label class="form-label" for="common-name">
                            <i class="fas fa-tag"></i> Common Name
                        </label>
                        <input type="text" id="common-name" class="form-input" 
                               placeholder="Local/common name" aria-label="Common name">
                    </div>
                </div>

                <!-- Location -->
                <div class="form-group">
                    <label class="form-label required" for="location">
                        <i class="fas fa-map-marker-alt"></i> Location
                    </label>
                    <input type="text" id="location" class="form-input" 
                           placeholder="Describe the location or address" required aria-label="Location description">
                    <div class="map-controls">
                        <button type="button" id="toggle-map" class="btn btn-outline" aria-label="Toggle map display">
                            <i class="fas fa-map"></i> <span id="map-toggle-text">Show Map</span>
                        </button>
                        <button type="button" id="use-my-location" class="btn btn-outline" aria-label="Use current location">
                            <i class="fas fa-location-arrow"></i> Use My Location
                        </button>
                    </div>
                    <div id="map-container">
                        <div id="map"></div>
                    </div>
                    <div id="location-status" class="status-message" style="display: none; margin-top: 0.5rem;"></div>
                </div>

                <!-- Habitat & Observation Type -->
                <div class="form-row">
                    <div class="form-col">
                        <label class="form-label required" for="habitat">
                            <i class="fas fa-tree"></i> Habitat Type
                        </label>
                        <select id="habitat" class="form-select" required aria-label="Habitat type">
                            <option value="">Select habitat type</option>
                            <option value="forest">üå≥ Forest</option>
                            <option value="wetland">üíß Wetland</option>
                            <option value="grassland">üåæ Grassland</option>
                            <option value="coastal">üèñÔ∏è Coastal</option>
                            <option value="urban">üèôÔ∏è Urban</option>
                            <option value="agricultural">üöú Agricultural</option>
                            <option value="alpine">‚õ∞Ô∏è Alpine</option>
                            <option value="riverine">üåä Riverine</option>
                            <option value="desert">üèúÔ∏è Desert</option>
                            <option value="other">üîç Other</option>
                        </select>
                    </div>
                    <div class="form-col">
                        <label class="form-label required" for="observation-type">
                            <i class="fas fa-binoculars"></i> Observation Type
                        </label>
                        <select id="observation-type" class="form-select" required aria-label="Observation type">
                            <option value="">Select type</option>
                            <option value="direct">üëÅÔ∏è Direct sighting</option>
                            <option value="scat">üí© Scat/droppings</option>
                            <option value="track">üë£ Track/footprint</option>
                            <option value="call">üéµ Call/sound</option>
                            <option value="nest">üè† Nest/den</option>
                            <option value="roadkill">üöó Roadkill</option>
                            <option value="feather">ü™∂ Feather</option>
                            <option value="bone">üíÄ Bone/skull</option>
                            <option value="other">üîç Other evidence</option>
                        </select>
                    </div>
                </div>

                <!-- Characteristics -->
                <div class="form-group">
                    <label class="form-label" for="characteristics">
                        <i class="fas fa-clipboard-list"></i> Description / Characteristics
                    </label>
                    <textarea id="characteristics" class="form-textarea" 
                              placeholder="Describe size, color, markings, behavior, age, sex, weather conditions, etc."
                              aria-label="Characteristics description"></textarea>
                </div>

                <!-- Notes -->
                <div class="form-group">
                    <label class="form-label" for="notes">
                        <i class="fas fa-sticky-note"></i> Additional Notes
                    </label>
                    <textarea id="notes" class="form-textarea" 
                              placeholder="Any other relevant observations or comments"
                              aria-label="Additional notes"></textarea>
                </div>

                <!-- Equipment Used -->
                <div class="form-group">
                    <label class="form-label">
                        <i class="fas fa-tools"></i> Equipment Used
                    </label>
                    <div class="checkbox-group">
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="binoculars" aria-label="Binoculars">
                            <i class="fas fa-eye"></i> Binoculars
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="camera" aria-label="Camera">
                            <i class="fas fa-camera"></i> Camera
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="hand-lens" aria-label="Hand lens">
                            <i class="fas fa-search"></i> Hand lens
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="gps" aria-label="GPS">
                            <i class="fas fa-map-pin"></i> GPS
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="microscope" aria-label="Microscope">
                            <i class="fas fa-microscope"></i> Microscope
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="other-equipment" aria-label="Other equipment">
                            <i class="fas fa-plus"></i> Other
                        </label>
                    </div>
                    <input type="text" id="other-equipment" class="form-input" 
                           placeholder="Specify other equipment used" style="margin-top: 0.75rem; display: none;"
                           aria-label="Other equipment details">
                </div>

                <!-- Reference Material -->
                <div class="form-group">
                    <label class="form-label" for="references">
                        <i class="fas fa-book-open"></i> Reference Material Used
                    </label>
                    <textarea id="references" class="form-textarea" 
                              placeholder="Field guides, apps, websites, or other references consulted"
                              aria-label="Reference material used"></textarea>
                </div>

                <!-- Photo -->
                <div class="form-group">
                    <label class="form-label">
                        <i class="fas fa-camera"></i> Photo / Evidence
                    </label>
                    <button type="button" id="capture-photo" class="btn btn-outline" aria-label="Take or upload photo">
                        <i class="fas fa-camera-retro"></i> Take photo/Upload
                    </button>
                    <input type="file" id="photo-upload" accept="image/*" capture="environment" style="display: none;" aria-label="Photo upload">
                    <div class="photo-container">
                        <div class="photo-preview-container">
                            <img id="photo-preview" class="photo-preview" alt="Photo preview">
                            <div id="photo-remove" class="photo-remove" title="Remove photo">
                                <i class="fas fa-times"></i>
                            </div>
                        </div>
                        <div id="photo-info" style="margin-top: 0.75rem; font-size: 0.9rem; color: #666; display: none;">
                            <span id="photo-size"><i class="fas fa-weight-hanging"></i> Size: --</span> | 
                            <span id="photo-resolution"><i class="fas fa-expand-alt"></i> Resolution: --</span>
                        </div>
                    </div>
                </div>

                <!-- Submit Button -->
                <button id="record-btn" class="btn btn-primary btn-block" aria-label="Record observation">
                    <i class="fas fa-save"></i> Record Observation
                </button>
            </div>

            <div id="record-status" class="status-message" style="display: none;"></div>
        </div>

        <!-- Logbook Panel -->
        <div id="logbook-panel" class="tab-panel">
            <div class="form-section">
                <h2 class="form-title">
                    <i class="fas fa-book"></i> Observation Logbook
                    <span class="badge" id="observation-count">0 observations</span>
                </h2>
                
                <div class="btn-group">
                    <button id="clear-logbook" class="btn btn-danger" aria-label="Clear all entries">
                        <i class="fas fa-trash-alt"></i> Clear All
                    </button>
                    <button id="import-logbook" class="btn btn-outline" aria-label="Import CSV">
                        <i class="fas fa-file-import"></i> Import CSV
                    </button>
                    <button id="download-template" class="btn btn-outline" aria-label="Download CSV template">
                        <i class="fas fa-download"></i> Download Template
                    </button>
                </div>
                
                <div class="logbook-entries" id="logbook-entries">
                    <!-- Log entries will be inserted here -->
                </div>
                
                <div id="empty-logbook" class="empty-state">
                    <i class="fas fa-book-open"></i>
                    <h3>No observations recorded yet</h3>
                    <p>Start by making your first observation in the Record tab!</p>
                </div>
            </div>
        </div>

        <!-- Export Panel -->
        <div id="export-panel" class="tab-panel">
            <!-- Import Section -->
            <div class="form-section import-section">
                <h2 class="form-title">
                    <i class="fas fa-file-import"></i> Import Observations
                </h2>
                <div class="form-group">
                    <label class="form-label" for="csv-import">
                        <i class="fas fa-file-csv"></i> Import CSV File
                    </label>
                    <input type="file" id="csv-import" accept=".csv" class="form-input" aria-label="CSV file to import">
                    
                    <div class="import-mode">
                        <div class="import-mode-option">
                            <label class="form-label tooltip" for="import-mode">
                                <i class="fas fa-cog"></i> Import Mode
                                <span class="tooltip-text">Append: Add new rows only | Replace: Clear all and import | Merge: Update existing and add new</span>
                            </label>
                            <select id="import-mode" class="form-select" aria-label="Import mode">
                                <option value="append">Append to existing data</option>
                                <option value="replace">Replace existing data</option>
                                <option value="merge">Merge and update existing</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="import-note">
                        <strong><i class="fas fa-info-circle"></i> Required format:</strong> CSV with headers: ID, Timestamp, Observer Name, Scientific Name, Common Name, Location, Latitude, Longitude, Habitat, Observation Type, Characteristics, Equipment, References, Notes, Has Photo.<br>
                        <strong><i class="fas fa-calendar-alt"></i> Date format:</strong> Use ISO format (YYYY-MM-DDTHH:mm:ss) for best results.<br>
                        <strong><i class="fas fa-shield-alt"></i> Safety note:</strong> Text starting with =, +, -, @ will be prefixed with ' to prevent formula execution.
                    </div>
                </div>
                
                <!-- CSV Preview & Validation Section -->
                <div id="csv-preview-section" class="csv-preview-section">
                    <h3><i class="fas fa-search"></i> CSV Preview & Validation</h3>
                    
                    <!-- Validation Statistics -->
                    <div id="validation-stats" class="validation-stats" style="display: none;">
                        <div id="stat-valid-rows" class="stat-item stat-valid">
                            <i class="fas fa-check-circle"></i> <span id="valid-count">0</span> valid
                        </div>
                        <div id="stat-invalid-rows" class="stat-item stat-invalid">
                            <i class="fas fa-times-circle"></i> <span id="invalid-count">0</span> invalid
                        </div>
                        <div id="stat-warning-rows" class="stat-item stat-warning">
                            <i class="fas fa-exclamation-triangle"></i> <span id="warning-count">0</span> warnings
                        </div>
                    </div>
                    
                    <div id="validation-summary" class="validation-summary"></div>
                    
                    <!-- Mini Map Preview for Coordinates -->
                    <div id="mini-map-container" class="mini-map-preview" style="display: none;"></div>
                    
                    <div id="preview-table-container" style="overflow: auto; max-height: 300px; border-radius: var(--border-radius-sm);">
                        <table id="csv-preview-table" class="csv-preview-table"></table>
                    </div>
                    <div id="preview-actions" class="btn-group" style="margin-top: 1.5rem;">
                        <button id="confirm-import" class="btn btn-primary">
                            <i class="fas fa-check"></i> Confirm Import
                        </button>
                        <button id="cancel-import" class="btn btn-outline">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>
                
                <button id="preview-import" class="btn btn-primary btn-block">
                    <i class="fas fa-eye"></i> Preview Import
                </button>
                <div id="import-status" class="status-message" style="display: none; margin-top: 1.5rem;"></div>
            </div>

            <!-- Export Section -->
            <div class="form-section export-options">
                <h2 class="form-title">
                    <i class="fas fa-file-export"></i> Export Observations
                </h2>
                
                <div class="batch-selection" id="batch-selection" style="display: none;">
                    <h3><i class="fas fa-check-square"></i> Select Observations to Export</h3>
                    <div class="batch-checkboxes" id="batch-checkboxes"></div>
                    <div class="btn-group">
                        <button id="select-all-btn" class="btn btn-outline btn-small">
                            <i class="fas fa-check-double"></i> Select All
                        </button>
                        <button id="deselect-all-btn" class="btn btn-outline btn-small">
                            <i class="fas fa-times"></i> Deselect All
                        </button>
                        <button id="apply-batch-selection" class="btn btn-primary btn-small">
                            <i class="fas fa-check"></i> Apply Selection
                        </button>
                    </div>
                </div>
                
                <div class="export-option-group">
                    <label class="form-label">
                        <i class="fas fa-file"></i> Export Format
                    </label>
                    <div class="export-option">
                        <input type="radio" id="export-pdf" name="export-format" value="pdf" checked aria-label="Export as PDF">
                        <label for="export-pdf">
                            <i class="fas fa-file-pdf"></i> PDF Field Log (with photos)
                        </label>
                    </div>
                    <div class="export-option">
                        <input type="radio" id="export-csv" name="export-format" value="csv" aria-label="Export as CSV">
                        <label for="export-csv">
                            <i class="fas fa-file-csv"></i> CSV Data
                        </label>
                    </div>
                    <div class="export-option">
                        <input type="checkbox" id="enable-batch-selection" aria-label="Enable batch selection">
                        <label for="enable-batch-selection">
                            <i class="fas fa-list-check"></i> Select specific observations
                        </label>
                    </div>
                </div>

                <div class="export-option-group">
                    <label class="form-label">
                        <i class="fas fa-calendar-alt"></i> Date Range (Optional)
                    </label>
                    <div class="date-range">
                        <div class="date-input">
                            <label class="form-label" style="font-size: 0.9rem;">From</label>
                            <input type="date" id="date-from" class="form-input" aria-label="Export from date">
                        </div>
                        <div class="date-input">
                            <label class="form-label" style="font-size: 0.9rem;">To</label>
                            <input type="date" id="date-to" class="form-input" aria-label="Export to date">
                        </div>
                    </div>
                </div>

                <button id="generate-export" class="btn btn-secondary btn-block" aria-label="Generate export">
                    <i class="fas fa-file-export"></i> Generate Export
                </button>
            </div>

            <div id="export-status" class="status-message" style="display: none;"></div>
            <div id="pdf-progress" class="pdf-status" style="display: none;">
                <div id="pdf-status-text">Preparing PDF...</div>
                <progress id="pdf-progress-bar" value="0" max="100"></progress>
                <div id="pdf-current-action"></div>
            </div>
            <div id="export-download" style="display: none; text-align: center; margin-top: 2rem;">
                <a id="download-link" class="btn btn-primary" download aria-label="Download export file">
                    <i class="fas fa-download"></i> Download Export
                </a>
            </div>
        </div>
    </div>

    <!-- Floating Action Button for Mobile -->
    <div class="fab" id="fab-add" title="Add new observation">
        <i class="fas fa-plus"></i>
    </div>

<script>
    // Dark Mode Functionality
    class DarkMode {
        constructor() {
            this.toggleBtn = document.getElementById('dark-mode-toggle');
            this.icon = this.toggleBtn.querySelector('i');
            this.init();
        }
        
        init() {
            // Check for saved preference
            const isDarkMode = localStorage.getItem('ecolens-dark-mode') === 'true';
            
            // Apply dark mode if saved
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                this.icon.classList.remove('fa-moon');
                this.icon.classList.add('fa-sun');
            }
            
            // Add event listener
            this.toggleBtn.addEventListener('click', () => this.toggle());
        }
        
        toggle() {
            const isDarkMode = document.body.classList.toggle('dark-mode');
            
            // Update icon
            if (isDarkMode) {
                this.icon.classList.remove('fa-moon');
                this.icon.classList.add('fa-sun');
            } else {
                this.icon.classList.remove('fa-sun');
                this.icon.classList.add('fa-moon');
            }
            
            // Save preference
            localStorage.setItem('ecolens-dark-mode', isDarkMode);
            
            // Dispatch event for map if needed
            if (EcoLens.map) {
                setTimeout(() => EcoLens.map.invalidateSize(), 100);
            }
        }
    }

    // Habitat types for dropdown
    const HABITAT_TYPES = [
        'forest', 'wetland', 'grassland', 'coastal', 'urban',
        'agricultural', 'alpine', 'riverine', 'desert', 'other'
    ];

    // Observation types
    const OBSERVATION_TYPES = [
        'direct', 'scat', 'track', 'call', 'nest',
        'roadkill', 'feather', 'bone', 'other'
    ];

    // Equipment options
    const EQUIPMENT_OPTIONS = [
        'binoculars', 'camera', 'hand-lens', 'gps', 'microscope',
        'hair-tube', 'pitfall-trap', 'camera-trap', 'other-equipment'
    ];

    // Expected CSV headers
    const EXPECTED_CSV_HEADERS = [
        'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
        'Latitude', 'Longitude', 'Habitat', 'Observation Type',
        'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
    ];

    // Required CSV headers
    const REQUIRED_CSV_HEADERS = [
        'Observer Name', 'Scientific Name', 'Location', 'Habitat', 'Observation Type'
    ];

    // Main application state
    const EcoLens = {
        observations: [],
        currentPhoto: null,
        map: null,
        mapMarker: null,
        mapEnabled: false,
        isLocating: false,
        isGeneratingPDF: false,
        csvPreviewData: null,
        selectedObservations: new Set(), // For batch export
        miniMap: null, // For coordinate preview
accuracyCircle: null,

        // Initialize the application
        init() {
            // Initialize dark mode
            this.darkMode = new DarkMode();
            this.loadObservations();
            this.setupEventListeners();
            this.renderLogbook();
            this.updateDateInputs();
            this.setCurrentDateTime();
            console.log('EcoLens initialized with', this.observations.length, 'observations');
            
            // Initialize photo remove button
            const photoRemoveBtn = document.getElementById('photo-remove');
            if (photoRemoveBtn) {
                photoRemoveBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removePhoto();
                });
            }
            
            // Initialize FAB button
            const fabBtn = document.getElementById('fab-add');
            if (fabBtn) {
                fabBtn.addEventListener('click', () => {
                    this.switchTab('record');
                    document.getElementById('observer-name').focus();
                    fabBtn.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        fabBtn.style.transform = 'scale(1)';
                    }, 200);
                });
            }
        },

        // Set current date/time in form
        setCurrentDateTime() {
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toTimeString().slice(0, 5);
            
            document.getElementById('observation-date').value = dateStr;
            document.getElementById('observation-time').value = timeStr;
        },

        // Generate a unique observation ID
        generateObservationId() {
            const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const random = Math.random().toString(36).substring(2, 7);
            return `ECO-${date}-${random}`.toUpperCase();
        },

        // Unified observation normalization function
        normalizeObservation(data) {
            // Generate ID if not provided
            const id = data.id || this.generateObservationId();
            
            // Parse and validate timestamp
            let timestamp;
            if (data.timestamp instanceof Date) {
                timestamp = data.timestamp.toISOString();
            } else if (typeof data.timestamp === 'string') {
                const date = new Date(data.timestamp);
                timestamp = !isNaN(date.getTime()) ? date.toISOString() : new Date().toISOString();
            } else {
                timestamp = new Date().toISOString();
            }
            
            // Ensure location object structure
            let location = data.location;
            if (typeof location === 'string' || !location) {
                location = {
                    text: location || '',
                    coordinates: data.coordinates || null,
                    accuracy: data.accuracy || null
                };
            }
            
            return {
                id,
                timestamp,
                observerName: (data.observerName || '').trim(),
                scientificName: (data.scientificName || '').trim(),
                commonName: (data.commonName || '').trim(),
                location,
                habitat: data.habitat || '',
                observationType: data.observationType || 'direct',
                characteristics: (data.characteristics || '').trim(),
                notes: (data.notes || '').trim(),
                equipment: Array.isArray(data.equipment) ? data.equipment : (data.equipment ? data.equipment.split(';').map(e => e.trim()).filter(e => e) : []),
                references: (data.references || '').trim(),
                photo: data.photo || null,
                metadata: {
                    deviceInfo: data.metadata?.deviceInfo || (data.source === 'import' ? 'Imported from CSV' : navigator.userAgent),
                    appVersion: '1.0',
                    lastModified: new Date().toISOString(),
                    source: data.metadata?.source || (data.source || 'manual')
                }
            };
        },

        // Create a new observation object with all fields
        createObservation(data) {
            return this.normalizeObservation({
                ...data,
                timestamp: new Date(data.date + 'T' + data.time)
            });
        },

        // Save observation to localStorage
        saveObservation(observation) {
            this.observations.unshift(observation); // Add to beginning for newest first
            localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
            this.renderLogbook();
        },

        // Load observations from localStorage
        loadObservations() {
            try {
                const saved = localStorage.getItem('ecolens_observations');
                this.observations = saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading observations:', error);
                this.observations = [];
            }
        },

        // Update an existing observation
        updateObservation(id, data) {
            const index = this.observations.findIndex(obs => obs.id === id);
            if (index !== -1) {
                const updatedObservation = this.normalizeObservation({
                    ...this.observations[index],
                    ...data,
                    id: this.observations[index].id, // Preserve original ID
                    timestamp: data.timestamp || this.observations[index].timestamp
                });
                
                this.observations[index] = updatedObservation;
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                this.renderLogbook();
                return true;
            }
            return false;
        },

        // Delete an observation
        deleteObservation(id) {
            if (confirm('Are you sure you want to delete this observation?')) {
                this.observations = this.observations.filter(obs => obs.id !== id);
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                this.renderLogbook();
                this.showStatus('Observation deleted successfully', 'success');
            }
        },

        // Clear all observations
        clearObservations() {
            if (this.observations.length === 0) {
                this.showStatus('Logbook is already empty', 'info', 'logbook');
                return;
            }

            if (confirm('Are you sure you want to clear ALL observations? This cannot be undone.')) {
                this.observations = [];
                localStorage.removeItem('ecolens_observations');
                this.renderLogbook();
                this.showStatus('All observations cleared successfully', 'success', 'logbook');
            }
        },

        // Sanitize CSV value to prevent formula injection
        sanitizeCSVValue(value) {
            if (!value || typeof value !== 'string') return value || '';
            
            // Check if value starts with formula characters
            const formulaChars = ['=', '+', '-', '@'];
            const firstChar = value.charAt(0);
            
            if (formulaChars.includes(firstChar)) {
                // Prefix with apostrophe to prevent formula execution in Excel/Sheets
                return "'" + value;
            }
            
            return value;
        },

        // Helper function for date parsing with warnings
        parseDateWithWarning(value, context = '') {
            const date = this.parseCSVTimestamp(value);
            if (!date || isNaN(date.getTime())) {
                console.warn(`Invalid date format${context ? ' in ' + context : ''}: "${value}"`);
                return null;
            }
            return date;
        },

        // Validate and parse CSV data with detailed error reporting
        validateAndParseCSV(csvContent) {
            const result = {
                headers: [],
                rows: [],
                errors: [],
                warnings: [],
                validRows: 0,
                invalidRows: 0,
                warningRows: 0,
                totalRows: 0,
                summary: '',
                hasCoordinates: false,
                coordinates: []
            };

            try {
                const lines = csvContent.split('\n').filter(line => line.trim() !== '');
                if (lines.length < 2) {
                    console.warn('CSV file is empty or has no data rows');
                    throw new Error('CSV file is empty or has no data rows');
                }

                // Parse headers
                result.headers = this.parseCSVLine(lines[0]).map(h => h.trim().replace(/"/g, ''));
                result.totalRows = lines.length - 1;

                // Check for expected headers
                const missingHeaders = EXPECTED_CSV_HEADERS.filter(h => !result.headers.includes(h));
                const extraHeaders = result.headers.filter(h => !EXPECTED_CSV_HEADERS.includes(h));

                if (missingHeaders.length > 0) {
                    const warning = `Missing expected headers: ${missingHeaders.join(', ')}`;
                    result.warnings.push(warning);
                    console.warn(warning);
                }

                if (extraHeaders.length > 0) {
                    const warning = `Extra headers found: ${extraHeaders.join(', ')}`;
                    result.warnings.push(warning);
                    console.warn(warning);
                }

                // Check if CSV has coordinate columns
                result.hasCoordinates = result.headers.includes('Latitude') && result.headers.includes('Longitude');

                // Parse data rows with validation
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const rowErrors = [];
                    const rowWarnings = [];
                    
                    try {
                        const row = this.parseCSVLine(line);
                        const rowData = {};
                        
                        // Map row data to headers
                        result.headers.forEach((header, index) => {
                            rowData[header] = row[index] || '';
                        });

                        // Sanitize all values to prevent CSV injection
                        Object.keys(rowData).forEach(key => {
                            if (typeof rowData[key] === 'string') {
                                rowData[key] = this.sanitizeCSVValue(rowData[key]);
                            }
                        });

                        // Validate required fields
                        REQUIRED_CSV_HEADERS.forEach(header => {
                            if (result.headers.includes(header)) {
                                const value = rowData[header];
                                if (!value || value.trim() === '') {
                                    const error = `Row ${i}: Missing required field "${header}"`;
                                    rowErrors.push(error);
                                    console.warn(error);
                                }
                            }
                        });

                        // Validate date format with clear guidance
                        if (result.headers.includes('Timestamp') && rowData['Timestamp']) {
                            const date = this.parseDateWithWarning(rowData['Timestamp'], `row ${i}`);
                            if (date) {
                                rowData['_parsedTimestamp'] = date;
                            } else {
                                rowWarnings.push(`Row ${i}: Invalid date format. Use ISO format (YYYY-MM-DDTHH:mm:ss) like "2023-12-25T14:30:00"`);
                            }
                        }

                        // Validate and parse coordinates if present
                        let hasValidCoords = false;
                        if (result.hasCoordinates && rowData['Latitude'] && rowData['Longitude']) {
                            const lat = parseFloat(rowData['Latitude']);
                            const lng = parseFloat(rowData['Longitude']);
                            
                            if (isNaN(lat) || lat < -90 || lat > 90) {
                                const warning = `Row ${i}: Invalid Latitude value "${rowData['Latitude']}". Must be between -90 and 90.`;
                                rowWarnings.push(warning);
                                console.warn(warning);
                            } else if (isNaN(lng) || lng < -180 || lng > 180) {
                                const warning = `Row ${i}: Invalid Longitude value "${rowData['Longitude']}". Must be between -180 and 180.`;
                                rowWarnings.push(warning);
                                console.warn(warning);
                            } else {
                                hasValidCoords = true;
                                result.coordinates.push({ lat, lng });
                                
                                // Add coordinate validation message
                                rowData['_coordinateStatus'] = '‚úÖ Valid coordinates';
                            }
                        } else if (rowData['Latitude'] || rowData['Longitude']) {
                            const warning = `Row ${i}: Incomplete coordinates. Provide both Latitude and Longitude or leave both empty.`;
                            rowWarnings.push(warning);
                            console.warn(warning);
                        }

                        // Add to results
                        result.rows.push({
                            data: rowData,
                            errors: rowErrors,
                            warnings: rowWarnings,
                            isValid: rowErrors.length === 0,
                            hasValidCoords: hasValidCoords,
                            rowNumber: i
                        });

                        if (rowErrors.length === 0) {
                            result.validRows++;
                            if (rowWarnings.length > 0) {
                                result.warningRows++;
                            }
                        } else {
                            result.invalidRows++;
                        }

                        // Add errors and warnings to overall lists
                        result.errors.push(...rowErrors);
                        result.warnings.push(...rowWarnings);

                    } catch (error) {
                        const errorMsg = `Row ${i}: ${error.message}`;
                        result.errors.push(errorMsg);
                        console.error(errorMsg);
                        result.rows.push({
                            data: null,
                            errors: [error.message],
                            warnings: [],
                            isValid: false,
                            hasValidCoords: false,
                            rowNumber: i
                        });
                        result.invalidRows++;
                    }
                }

                // Create summary
                result.summary = `Found ${result.totalRows} rows: ${result.validRows} valid, ${result.invalidRows} invalid, ${result.warningRows} with warnings`;

                return result;

            } catch (error) {
                const errorMsg = `CSV parsing error: ${error.message}`;
                result.errors.push(errorMsg);
                console.error(errorMsg);
                return result;
            }
        },

        // Show CSV preview with validation results
        showCSVPreview(validationResult) {
            const previewSection = document.getElementById('csv-preview-section');
            const statsDiv = document.getElementById('validation-stats');
            const summaryDiv = document.getElementById('validation-summary');
            const previewTable = document.getElementById('csv-preview-table');
            const miniMapContainer = document.getElementById('mini-map-container');
            
            // Clear previous content
            statsDiv.innerHTML = '';
            summaryDiv.innerHTML = '';
            previewTable.innerHTML = '';
            
            // Show validation statistics with new format
            statsDiv.style.display = 'flex';
            document.getElementById('valid-count').textContent = `${validationResult.validRows}`;
            document.getElementById('invalid-count').textContent = `${validationResult.invalidRows}`;
            document.getElementById('warning-count').textContent = `${validationResult.warningRows}`;
            
            // Show validation summary
            let summaryHTML = `<div class="status-${validationResult.errors.length > 0 ? 'error' : validationResult.warnings.length > 0 ? 'warning' : 'success'} validation-summary">`;
            summaryHTML += `<strong>Validation Summary:</strong> ${validationResult.summary}`;
            
            if (validationResult.errors.length > 0) {
                summaryHTML += '<div class="validation-errors">';
                summaryHTML += '<strong>Critical Errors (must be fixed):</strong>';
                const errorCount = Math.min(validationResult.errors.length, 5);
                for (let i = 0; i < errorCount; i++) {
                    summaryHTML += `<div class="validation-error">${validationResult.errors[i]}</div>`;
                }
                if (validationResult.errors.length > 5) {
                    summaryHTML += `<div class="validation-error">... and ${validationResult.errors.length - 5} more errors</div>`;
                }
                summaryHTML += '</div>';
            }
            
            if (validationResult.warnings.length > 0) {
                summaryHTML += '<div class="validation-errors">';
                summaryHTML += '<strong>Warnings (should be reviewed):</strong>';
                const warningCount = Math.min(validationResult.warnings.length, 5);
                for (let i = 0; i < warningCount; i++) {
                    summaryHTML += `<div class="validation-warning">${validationResult.warnings[i]}</div>`;
                }
                if (validationResult.warnings.length > 5) {
                    summaryHTML += `<div class="validation-warning">... and ${validationResult.warnings.length - 5} more warnings</div>`;
                }
                summaryHTML += '</div>';
            }
            
            // Date format guidance
            summaryHTML += '<div style="margin-top: 1rem; padding: 0.5rem; background: #e8f4fc; border-radius: 4px;">';
            summaryHTML += '<strong>üìÖ Date Format Guidance:</strong><br>';
            summaryHTML += '‚Ä¢ Use ISO format for best results: <code>2023-12-25T14:30:00</code><br>';
            summaryHTML += '‚Ä¢ Or use unambiguous formats: <code>25/12/2023 14:30</code> or <code>12/25/2023 2:30 PM</code><br>';
            summaryHTML += '‚Ä¢ Avoid ambiguous formats like <code>01/02/2023</code> (could be Jan 2 or Feb 1)';
            summaryHTML += '</div>';
            
            summaryHTML += '</div>';
            summaryDiv.innerHTML = summaryHTML;
            
            // Show mini map for coordinates if available
            if (validationResult.hasCoordinates && validationResult.coordinates.length > 0) {
                this.showMiniMap(validationResult.coordinates);
                miniMapContainer.style.display = 'block';
            } else {
                miniMapContainer.style.display = 'none';
            }
            
            // Show preview table (limit to first 10 rows for performance)
            const maxPreviewRows = 10;
            const rowsToShow = validationResult.rows.slice(0, maxPreviewRows);
            
            if (rowsToShow.length > 0) {
                // Create table headers
                let tableHTML = '<thead><tr>';
                validationResult.headers.forEach(header => {
                    tableHTML += `<th>${header}</th>`;
                });
                tableHTML += '<th>Status</th></tr></thead><tbody>';
                
                // Create table rows
                rowsToShow.forEach((row, rowIndex) => {
                    let rowClass = '';
                    let status = '';
                    
                    if (row.errors.length > 0) {
                        rowClass = 'error-row';
                        status = `‚ùå ${row.errors.length} error(s)`;
                    } else if (row.warnings.length > 0) {
                        rowClass = 'warning-row';
                        status = `‚ö†Ô∏è ${row.warnings.length} warning(s)`;
                    } else {
                        status = '‚úÖ Valid';
                    }
                    
                    // Add coordinate status if available
                    if (row.data && row.data['_coordinateStatus']) {
                        status += ` | ${row.data['_coordinateStatus']}`;
                    }
                    
                    tableHTML += `<tr class="${rowClass}" title="Row ${row.rowNumber}">`;
                    
                    validationResult.headers.forEach(header => {
                        const value = row.data ? row.data[header] || '' : '';
                        const displayValue = value.length > 30 ? value.substring(0, 30) + '...' : value;
                        const title = value.length > 30 ? value : '';
                        tableHTML += `<td title="${this.escapeHtml(title)}">${this.escapeHtml(displayValue)}</td>`;
                    });
                    
                    tableHTML += `<td>${status}</td></tr>`;
                });
                
                if (validationResult.rows.length > maxPreviewRows) {
                    tableHTML += `<tr><td colspan="${validationResult.headers.length + 1}" style="text-align: center; font-style: italic;">
                        ... and ${validationResult.rows.length - maxPreviewRows} more rows
                    </td></tr>`;
                }
                
                tableHTML += '</tbody>';
                previewTable.innerHTML = tableHTML;
            }
            
            // Show preview section
            previewSection.style.display = 'block';
            previewSection.scrollIntoView({ behavior: 'smooth' });
        },

        // Show mini map for coordinate preview
        showMiniMap(coordinates) {
            const container = document.getElementById('mini-map-container');
            container.innerHTML = '';
            
            if (coordinates.length === 0) return;
            
            // Calculate bounds for all coordinates
            const bounds = coordinates.reduce((acc, coord) => {
                if (coord && coord.lat && coord.lng) {
                    acc.push([coord.lat, coord.lng]);
                }
                return acc;
            }, []);
            
            if (bounds.length === 0) return;
            
            // Create mini map
            this.miniMap = L.map(container).setView(bounds[0], 5);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(this.miniMap);
            
            // Add markers for each coordinate
            coordinates.forEach(coord => {
                if (coord && coord.lat && coord.lng) {
                    L.marker([coord.lat, coord.lng]).addTo(this.miniMap);
                }
            });
            
            // Fit bounds if multiple coordinates
            if (bounds.length > 1) {
                this.miniMap.fitBounds(bounds);
            }
        },

        // Import observations from CSV with proper merging
        importObservations(validationResult, mode = 'append') {
            try {
                const importedObservations = [];
                let successCount = 0;
                let errorCount = 0;
                let updateCount = 0;

                // Process only valid rows
                validationResult.rows.forEach(row => {
                    if (row.isValid && row.data) {
                        try {
                            const observation = this.normalizeObservation({
                                id: row.data['ID'],
                                timestamp: row.data['_parsedTimestamp'] || row.data['Timestamp'],
                                observerName: row.data['Observer Name'],
                                scientificName: row.data['Scientific Name'],
                                commonName: row.data['Common Name'],
                                location: {
                                    text: row.data['Location'] || '',
                                    coordinates: (row.data['Latitude'] && row.data['Longitude']) ? {
                                        lat: parseFloat(row.data['Latitude']),
                                        lng: parseFloat(row.data['Longitude'])
                                    } : null
                                },
                                habitat: row.data['Habitat'],
                                observationType: row.data['Observation Type'],
                                characteristics: row.data['Characteristics'],
                                equipment: row.data['Equipment'],
                                references: row.data['References'],
                                notes: row.data['Notes'],
                                source: 'import'
                            });

                            importedObservations.push(observation);
                            successCount++;
                        } catch (error) {
                            console.warn('Error creating observation from row:', error, row.data);
                            errorCount++;
                        }
                    } else {
                        errorCount++;
                    }
                });

                if (importedObservations.length === 0) {
                    throw new Error('No valid observations found in CSV file');
                }

                // Handle import based on mode
                const existingIds = new Set(this.observations.map(obs => obs.id));
                
                switch (mode) {
                    case 'replace':
                        // Completely replace existing data
                        this.observations = importedObservations;
                        break;
                        
                    case 'merge':
                        // Merge and update existing observations
                        const observationMap = new Map();
                        
                        // Add all existing observations to map
                        this.observations.forEach(obs => {
                            observationMap.set(obs.id, obs);
                        });
                        
                        // Merge imported observations
                        importedObservations.forEach(importedObs => {
                            if (observationMap.has(importedObs.id)) {
                                // Update existing observation
                                const existingObs = observationMap.get(importedObs.id);
                                observationMap.set(importedObs.id, this.normalizeObservation({
                                    ...existingObs,
                                    ...importedObs,
                                    metadata: {
                                        ...existingObs.metadata,
                                        source: 'merged'
                                    }
                                }));
                                updateCount++;
                            } else {
                                // Add new observation
                                observationMap.set(importedObs.id, importedObs);
                            }
                        });
                        
                        this.observations = Array.from(observationMap.values());
                        break;
                        
                    case 'append':
                    default:
                        // Append, avoiding duplicates by ID
                        const uniqueImports = importedObservations.filter(obs => !existingIds.has(obs.id));
                        this.observations = [...this.observations, ...uniqueImports];
                        break;
                }

                // Sort by timestamp (newest first)
                this.observations.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                // Save to localStorage
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                this.renderLogbook();

                return {
                    success: true,
                    imported: successCount,
                    updated: updateCount,
                    errors: errorCount,
                    total: this.observations.length,
                    mode: mode
                };

            } catch (error) {
                console.error('Import error:', error);
                throw error;
            }
        },

        // Parse CSV line with quoted fields
        parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Escaped quote
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Start or end of quoted field
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add last field
            result.push(current);
            
            // Remove quotes from fields
            return result.map(field => field.replace(/^"(.*)"$/, '$1').trim());
        },

        // Parse timestamp from CSV with multiple format support
        parseCSVTimestamp(timestampStr) {
            if (!timestampStr) return null;
            
            // Try different date formats
            const formats = [
                // ISO format (YYYY-MM-DDTHH:mm:ss)
                () => {
                    try {
                        // Try standard ISO format
                        const date = new Date(timestampStr);
                        if (!isNaN(date.getTime())) return date;
                        
                        // Try without timezone
                        const isoMatch = timestampStr.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})$/);
                        if (isoMatch) {
                            const [_, year, month, day, hour, minute, second] = isoMatch;
                            const date = new Date(year, month - 1, day, hour, minute, second);
                            if (!isNaN(date.getTime())) return date;
                        }
                        return null;
                    } catch {
                        return null;
                    }
                },
                // US format (MM/DD/YYYY HH:MM:SS)
                () => {
                    try {
                        const usMatch = timestampStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})[,\s]+(\d{1,2}):(\d{2}):(\d{2})/);
                        if (usMatch) {
                            const [_, month, day, year, hour, minute, second] = usMatch;
                            const date = new Date(year, month - 1, day, hour, minute, second);
                            if (!isNaN(date.getTime())) return date;
                        }
                        return null;
                    } catch {
                        return null;
                    }
                },
                // EU format (DD/MM/YYYY HH:MM:SS)
                () => {
                    try {
                        const euMatch = timestampStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})[,\s]+(\d{1,2}):(\d{2}):(\d{2})/);
                        if (euMatch) {
                            const [_, day, month, year, hour, minute, second] = euMatch;
                            const date = new Date(year, month - 1, day, hour, minute, second);
                            if (!isNaN(date.getTime())) return date;
                        }
                        return null;
                    } catch {
                        return null;
                    }
                },
                // Date only (try multiple formats)
                () => {
                    try {
                        const date = new Date(timestampStr);
                        if (!isNaN(date.getTime())) return date;
                        return null;
                    } catch {
                        return null;
                    }
                }
            ];
            
            for (const format of formats) {
                const result = format();
                if (result) return result;
            }
            
            return null;
        },

        // Helper for batch operations
        getObservationsByIds(ids) {
            return this.observations.filter(obs => ids.has(obs.id));
        },

        // Get filtered observations for export
        getFilteredObservations(startDate = null, endDate = null, selectedIds = null) {
            let filtered = this.observations;
            
            // Filter by date range
            if (startDate || endDate) {
                filtered = filtered.filter(obs => {
                    const obsDate = new Date(obs.timestamp);
                    if (startDate && obsDate < new Date(startDate)) return false;
                    if (endDate && obsDate > new Date(endDate + 'T23:59:59')) return false;
                    return true;
                });
            }
            
            // Filter by selected IDs
            if (selectedIds && selectedIds.size > 0) {
                filtered = filtered.filter(obs => selectedIds.has(obs.id));
            }
            
            return filtered;
        },

        // Setup all event listeners
        setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    this.switchTab(tab);
                });
            });

            // Set current date/time button
            document.getElementById('set-now').addEventListener('click', () => {
                this.setCurrentDateTime();
            });

            // Record observation
            document.getElementById('record-btn').addEventListener('click', () => {
                this.handleRecordObservation();
            });

            // Map toggle
            document.getElementById('toggle-map').addEventListener('click', () => {
                this.toggleMap();
            });

            // Use my location
            document.getElementById('use-my-location').addEventListener('click', () => {
                this.getUserLocation();
            });

            // Photo handling
            document.getElementById('capture-photo').addEventListener('click', () => {
                document.getElementById('photo-upload').click();
            });

            document.getElementById('photo-upload').addEventListener('change', (e) => {
                this.handlePhotoUpload(e);
            });

            // Equipment other input toggle
            document.querySelectorAll('input[name="equipment"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    if (e.target.value === 'other-equipment') {
                        document.getElementById('other-equipment').style.display = 
                            e.target.checked ? 'block' : 'none';
                    }
                });
            });

            // Export generation
            document.getElementById('generate-export').addEventListener('click', () => {
                this.handleExport();
            });

            // Import handling
            document.getElementById('preview-import').addEventListener('click', () => {
                this.handlePreviewImport();
            });

            document.getElementById('confirm-import').addEventListener('click', () => {
                this.handleConfirmImport();
            });

            document.getElementById('cancel-import').addEventListener('click', () => {
                this.hideCSVPreview();
            });

            // Clear logbook
            document.getElementById('clear-logbook').addEventListener('click', () => {
                this.clearObservations();
            });

            // Download CSV template
            document.getElementById('download-template').addEventListener('click', () => {
                this.downloadCSVTemplate();
            });

            // Import logbook button in logbook panel
            document.getElementById('import-logbook').addEventListener('click', () => {
                this.switchTab('export');
                setTimeout(() => {
                    document.getElementById('csv-import').click();
                }, 100);
            });

            // Batch selection
            document.getElementById('enable-batch-selection').addEventListener('change', (e) => {
                this.toggleBatchSelection(e.target.checked);
            });

            document.getElementById('select-all-btn').addEventListener('click', () => {
                this.selectAllObservations();
            });

            document.getElementById('deselect-all-btn').addEventListener('click', () => {
                this.deselectAllObservations();
            });

            document.getElementById('apply-batch-selection').addEventListener('click', () => {
                this.applyBatchSelection();
            });

            // Form inputs - clear status on change
            document.querySelectorAll('#record-panel input, #record-panel textarea, #record-panel select')
                .forEach(input => {
                    input.addEventListener('input', () => {
                        document.getElementById('record-status').style.display = 'none';
                    });
                });

            // Keyboard navigation for forms
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.target.tagName === 'INPUT' && !e.target.type.includes('checkbox') && !e.target.type.includes('radio')) {
                    e.preventDefault();
                    const form = e.target.closest('form') || document.getElementById('record-panel');
                    const inputs = Array.from(form.querySelectorAll('input, select, textarea'));
                    const index = inputs.indexOf(e.target);
                    if (index !== -1 && index < inputs.length - 1) {
                        inputs[index + 1].focus();
                    } else if (index === inputs.length - 1) {
                        document.getElementById('record-btn').click();
                    }
                }
            });
        },

        // Handle CSV preview
        handlePreviewImport() {
            const fileInput = document.getElementById('csv-import');
            const file = fileInput.files[0];
            
            if (!file) {
                this.showStatus('Please select a CSV file to import', 'error', 'export');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const previewBtn = document.getElementById('preview-import');
                    const originalText = previewBtn.textContent;
                    previewBtn.innerHTML = '<span class="loading"></span> Validating...';
                    previewBtn.disabled = true;

                    // Validate and parse CSV
                    const validationResult = this.validateAndParseCSV(e.target.result);
                    this.csvPreviewData = validationResult;
                    
                    // Show preview
                    this.showCSVPreview(validationResult);
                    
                    previewBtn.textContent = originalText;
                    previewBtn.disabled = false;

                } catch (error) {
                    document.getElementById('preview-import').textContent = 'üëÅÔ∏è Preview Import';
                    document.getElementById('preview-import').disabled = false;
                    this.showStatus(`Validation failed: ${error.message}`, 'error', 'export');
                    console.error('Validation error:', error);
                }
            };

            reader.onerror = () => {
                document.getElementById('preview-import').textContent = 'üëÅÔ∏è Preview Import';
                document.getElementById('preview-import').disabled = false;
                this.showStatus('Error reading file', 'error', 'export');
            };

            reader.readAsText(file, 'UTF-8');
        },

        // Handle confirmed import
        handleConfirmImport() {
            if (!this.csvPreviewData) {
                this.showStatus('No CSV data to import', 'error', 'export');
                return;
            }

            const mode = document.getElementById('import-mode').value;
            
            if (mode === 'replace' && this.observations.length > 0) {
                if (!confirm('WARNING: This will replace ALL existing observations with the imported data. Are you sure?')) {
                    return;
                }
            }

            try {
                const confirmBtn = document.getElementById('confirm-import');
                const originalText = confirmBtn.textContent;
                confirmBtn.innerHTML = '<span class="loading"></span> Importing...';
                confirmBtn.disabled = true;

                const result = this.importObservations(this.csvPreviewData, mode);
                
                confirmBtn.textContent = originalText;
                confirmBtn.disabled = false;
                
                // Clear file input and hide preview
                document.getElementById('csv-import').value = '';
                this.hideCSVPreview();

                let message = `Import successful! ${result.imported} observations imported. `;
                if (result.mode === 'merge') {
                    message += `${result.updated} observations updated. `;
                }
                message += `Total observations: ${result.total}`;
                
                if (result.errors > 0) {
                    message += ` (${result.errors} rows had errors and were skipped)`;
                }

                this.showStatus(message, 'success', 'export');

                // Switch to logbook tab to see imported data
                setTimeout(() => this.switchTab('logbook'), 1500);

            } catch (error) {
                document.getElementById('confirm-import').textContent = '‚úÖ Confirm Import';
                document.getElementById('confirm-import').disabled = false;
                this.showStatus(`Import failed: ${error.message}`, 'error', 'export');
                console.error('Import error:', error);
            }
        },

        // Hide CSV preview
        hideCSVPreview() {
            document.getElementById('csv-preview-section').style.display = 'none';
            document.getElementById('validation-stats').style.display = 'none';
            document.getElementById('csv-import').value = '';
            this.csvPreviewData = null;
            
            // Clean up mini map
            if (this.miniMap) {
                try {
                    this.miniMap.remove();
                } catch (e) {
                    console.warn('Error removing mini map:', e);
                }
                this.miniMap = null;
            }
            document.getElementById('mini-map-container').innerHTML = '';
            document.getElementById('mini-map-container').style.display = 'none';
        },

        // Download CSV template
        downloadCSVTemplate() {
            const headers = EXPECTED_CSV_HEADERS;
            const exampleRow = [
                'ECO-20231225-ABC12',
                '2023-12-25T14:30:00', // ISO format example
                'Jane Doe',
                'Canis lupus',
                'Gray Wolf',
                'Yellowstone National Park, Wyoming',
                '44.4280',
                '-110.5885',
                'forest',
                'direct',
                'Large adult, gray coat, observed hunting',
                'binoculars; camera',
                'Field Guide to North American Mammals',
                'Observed from 100m distance',
                'No'
            ];
            
            const csvContent = [
                headers.join(','),
                exampleRow.map(field => `"${field}"`).join(','),
                '',
                'üìÖ Date Format Notes:',
                '‚Ä¢ Use ISO format for best results: YYYY-MM-DDTHH:mm:ss (e.g., 2023-12-25T14:30:00)',
                '‚Ä¢ Alternative formats: MM/DD/YYYY HH:MM:SS or DD/MM/YYYY HH:MM:SS',
                '‚Ä¢ Avoid ambiguous formats like 01/02/2023',
                '',
                'üìç Coordinate Notes:',
                '‚Ä¢ Latitude: -90 to 90 (negative = South)',
                '‚Ä¢ Longitude: -180 to 180 (negative = West)',
                '‚Ä¢ Use decimal degrees (e.g., 44.4280, -110.5885)',
                '',
                '‚ö†Ô∏è Safety Note:',
                '‚Ä¢ Text starting with =, +, -, @ will be prefixed with apostrophe',
                '‚Ä¢ This prevents formula execution in spreadsheet software'
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'EcoLens_Import_Template.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            this.showStatus('CSV template downloaded', 'success', 'logbook');
        },

        // Toggle batch selection UI
        toggleBatchSelection(show) {
            const batchSection = document.getElementById('batch-selection');
            if (show) {
                batchSection.style.display = 'block';
                this.renderBatchCheckboxes();
            } else {
                batchSection.style.display = 'none';
                this.selectedObservations.clear();
            }
        },

        // Render batch selection checkboxes
        renderBatchCheckboxes() {
            const container = document.getElementById('batch-checkboxes');
            container.innerHTML = '';
            
            this.observations.forEach(obs => {
                const date = new Date(obs.timestamp).toLocaleDateString();
                const div = document.createElement('div');
                div.className = 'batch-checkbox-item';
                div.innerHTML = `
                    <input type="checkbox" id="batch-${obs.id}" value="${obs.id}" 
                           ${this.selectedObservations.has(obs.id) ? 'checked' : ''}>
                    <label for="batch-${obs.id}">
                        ${date} - ${obs.scientificName} (${obs.id})
                    </label>
                `;
                container.appendChild(div);
                
                // Add event listener
                const checkbox = div.querySelector('input');
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.selectedObservations.add(obs.id);
                    } else {
                        this.selectedObservations.delete(obs.id);
                    }
                });
            });
        },

        // Select all observations for batch export
        selectAllObservations() {
            this.observations.forEach(obs => {
                this.selectedObservations.add(obs.id);
            });
            this.renderBatchCheckboxes();
        },

        // Deselect all observations for batch export
        deselectAllObservations() {
            this.selectedObservations.clear();
            this.renderBatchCheckboxes();
        },

        // Apply batch selection
        applyBatchSelection() {
            const batchSection = document.getElementById('batch-selection');
            batchSection.style.display = 'none';
            this.showStatus(`${this.selectedObservations.size} observations selected for export`, 'info', 'export');
        },

        // Switch between tabs
        switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Show selected panel
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `${tabName}-panel`);
            });

            // Hide export download section when switching away
            if (tabName !== 'export') {
                document.getElementById('export-download').style.display = 'none';
                document.getElementById('pdf-progress').style.display = 'none';
                this.hideCSVPreview();
            }
            
            // Refresh logbook when switching to it
            if (tabName === 'logbook') {
                this.renderLogbook();
            }
            
            // Scroll to top when switching tabs on mobile
            if (window.innerWidth < 768) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        },

        // Handle recording a new observation
        handleRecordObservation() {
            // Get all form values
            const date = document.getElementById('observation-date').value;
            const time = document.getElementById('observation-time').value;
            const observerName = document.getElementById('observer-name').value.trim();
            const scientificName = document.getElementById('scientific-name').value.trim();
            const commonName = document.getElementById('common-name').value.trim();
            const location = document.getElementById('location').value.trim();
            const habitat = document.getElementById('habitat').value;
            const observationType = document.getElementById('observation-type').value;
            const characteristics = document.getElementById('characteristics').value.trim();
            const notes = document.getElementById('notes').value.trim();
            const references = document.getElementById('references').value.trim();

            // Get equipment used
            const equipment = [];
            document.querySelectorAll('input[name="equipment"]:checked').forEach(cb => {
                equipment.push(cb.value);
            });
            
            // Add other equipment if specified
            const otherEquipment = document.getElementById('other-equipment').value.trim();
            if (otherEquipment && equipment.includes('other-equipment')) {
                equipment[equipment.indexOf('other-equipment')] = `other: ${otherEquipment}`;
            }

            // Validation
            if (!date || !time) {
                this.showStatus('Please enter observation date and time', 'error');
                return;
            }

            if (!observerName) {
                this.showStatus('Please enter observer name', 'error');
                document.getElementById('observer-name').focus();
                return;
            }

            if (!scientificName) {
                this.showStatus('Please enter scientific name', 'error');
                document.getElementById('scientific-name').focus();
                return;
            }

            if (!location && !this.mapMarker) {
                this.showStatus('Please enter a location or use the map', 'error');
                return;
            }

            if (!habitat) {
                this.showStatus('Please select habitat type', 'error');
                return;
            }

            if (!observationType) {
                this.showStatus('Please select observation type', 'error');
                return;
            }

            // Get coordinates if map is enabled
            let coordinates = null;
            let accuracy = null;
            if (this.mapMarker) {
                const latlng = this.mapMarker.getLatLng();
                coordinates = { lat: latlng.lat, lng: latlng.lng };
                accuracy = this.mapMarker.options.accuracy || null;
            }

            // Create observation
            const observation = this.createObservation({
                date,
                time,
                observerName,
                scientificName,
                commonName,
                location: location || 'Map location selected',
                coordinates,
                accuracy,
                habitat,
                observationType,
                characteristics,
                notes,
                equipment,
                references,
                photo: this.currentPhoto
            });

            // Save and reset form
            this.saveObservation(observation);
            this.resetForm();
            this.showStatus(`Observation ${observation.id} recorded successfully!`, 'success');
            
            // Switch to logbook tab
            setTimeout(() => this.switchTab('logbook'), 1500);
        },

        // Reset the form
        resetForm() {
            // Reset all form fields
            this.setCurrentDateTime();
            document.getElementById('observer-name').value = '';
            document.getElementById('scientific-name').value = '';
            document.getElementById('common-name').value = '';
            document.getElementById('location').value = '';
            document.getElementById('habitat').value = '';
            document.getElementById('observation-type').value = '';
            document.getElementById('characteristics').value = '';
            document.getElementById('notes').value = '';
            document.getElementById('references').value = '';
            
            // Reset equipment checkboxes
            document.querySelectorAll('input[name="equipment"]').forEach(cb => {
                cb.checked = false;
            });
            document.getElementById('other-equipment').style.display = 'none';
            document.getElementById('other-equipment').value = '';
            
            // Reset photo
            this.removePhoto();
            
            // Reset map
            if (this.mapMarker) {
                this.map.removeLayer(this.mapMarker);
                this.mapMarker = null;
            }
            
            // Hide map if shown
            if (this.mapEnabled) {
                this.toggleMap(false);
            }
            
            // Reset location status
            document.getElementById('location-status').style.display = 'none';
            
            // Reset record button if editing
            const recordBtn = document.getElementById('record-btn');
            if (recordBtn.dataset.editingId) {
                recordBtn.textContent = '<i class="fas fa-save"></i> Record Observation';
                recordBtn.onclick = () => this.handleRecordObservation();
                delete recordBtn.dataset.editingId;
            }
            
            // Focus on first field
            document.getElementById('observer-name').focus();
        },

        // Remove photo
        removePhoto() {
            this.currentPhoto = null;
            document.getElementById('photo-preview').style.display = 'none';
            document.getElementById('photo-preview').src = '';
            document.getElementById('photo-upload').value = '';
            document.getElementById('photo-info').style.display = 'none';
            document.getElementById('photo-remove').style.display = 'none';
        },

        // Toggle map visibility
        toggleMap(show = null) {
            const mapContainer = document.getElementById('map-container');
            const toggleBtn = document.getElementById('toggle-map');
            const toggleText = document.getElementById('map-toggle-text');
            
            this.mapEnabled = show !== null ? show : !this.mapEnabled;
            
            if (this.mapEnabled) {
                // Show map
                mapContainer.style.display = 'block';
                toggleText.textContent = 'Hide Map';
                
                // Initialize map if not already done
                if (!this.map) {
                    this.initMap();
                } else {
                    // Update map size if it was hidden
                    setTimeout(() => {
                        this.map.invalidateSize();
                    }, 100);
                }
            } else {
                // Hide map
                mapContainer.style.display = 'none';
                toggleText.textContent = 'Show Map';
            }
        },

        // Initialize Leaflet map
        initMap() {
            // Default to Canberra if no location yet
            const defaultCenter = [-35.2809, 149.1300];
            this.map = L.map('map').setView(defaultCenter, 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(this.map);

            // Add click handler for map
            this.map.on('click', (e) => {
                this.addMarker(e.latlng);
            });
        },

// Add marker to map
addMarker(latlng, accuracy = null) {
    if (this.mapMarker) {
        this.map.removeLayer(this.mapMarker);
        // Also remove any existing accuracy circle
        if (this.accuracyCircle) {
            this.map.removeLayer(this.accuracyCircle);
        }
    }
    
    // Create marker
    this.mapMarker = L.marker(latlng).addTo(this.map);
    this.mapMarker.options.accuracy = accuracy;
    
    // Add accuracy circle if accuracy is provided
    if (accuracy) {
        this.accuracyCircle = L.circle(latlng, {
            radius: accuracy,
            color: '#3498db',
            fillColor: '#3498db',
            fillOpacity: 0.1,
            weight: 1
        }).addTo(this.map);
    }
    
    // Update location field
    const lat = latlng.lat.toFixed(6);
    const lng = latlng.lng.toFixed(6);
    document.getElementById('location').value = `Lat: ${lat}, Lng: ${lng}`;
    
    // Center map on marker
    this.map.setView(latlng, Math.max(this.map.getZoom(), 15));
},

// Get user's current location - FIXED VERSION
getUserLocation() {
    if (!navigator.geolocation) {
        this.showLocationStatus('Geolocation is not supported by your browser', 'error');
        return;
    }

    // Prevent multiple location requests
    if (this.isLocating) {
        this.showLocationStatus('Already getting location...', 'info');
        return;
    }

    this.isLocating = true;
    const locateBtn = document.getElementById('use-my-location');
    const originalHTML = locateBtn.innerHTML;
    locateBtn.innerHTML = '<span class="loading"></span> Locating...';
    locateBtn.disabled = true;

    this.showLocationStatus('Getting your location...', 'info');

    navigator.geolocation.getCurrentPosition(
        (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            console.log('Location acquired:', { lat, lng, accuracy });
            
            // Make sure map is initialized and visible
            if (!this.map) {
                this.initMap();
            }
            
            // Show map if not already shown
            if (!this.mapEnabled) {
                this.toggleMap(true);
            }
            
            // Small delay to ensure map is fully loaded
            setTimeout(() => {
                // Add marker at user's location
                this.addMarker([lat, lng], accuracy);
                
                // Update status
                const accuracyMsg = accuracy ? ` (accuracy: ¬±${Math.round(accuracy)}m)` : '';
                this.showLocationStatus(`Location acquired${accuracyMsg}`, 'success');
                
                // Update location text field
                const latlng = [lat, lng];
                const latFormatted = latlng[0].toFixed(6);
                const lngFormatted = latlng[1].toFixed(6);
                document.getElementById('location').value = `Lat: ${latFormatted}, Lng: ${lngFormatted}`;
                
                // Center map on marker
                this.map.setView(latlng, Math.max(this.map.getZoom(), 15));
            }, 100);
            
            this.isLocating = false;
            locateBtn.innerHTML = originalHTML;
            locateBtn.disabled = false;
        },
        (error) => {
            console.error('Geolocation error:', error);
            let message = 'Unable to get your location';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'Location permission denied. Please enable location services for this site in your browser settings.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'Location information unavailable. Please check your device location settings.';
                    break;
                case error.TIMEOUT:
                    message = 'Location request timed out. Please try again.';
                    break;
                default:
                    message = 'An unknown error occurred while getting location.';
            }
            
            this.showLocationStatus(message, 'error');
            this.isLocating = false;
            locateBtn.innerHTML = originalHTML;
            locateBtn.disabled = false;
        },
        {
            enableHighAccuracy: true,
            timeout: 15000,  // Increased to 15 seconds
            maximumAge: 0    // Don't use cached location
        }
    );
},

        // Handle photo upload with compression
        handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                this.showStatus('Please select an image file', 'error');
                return;
            }

            // Check file size (max 5MB before compression)
            if (file.size > 5 * 1024 * 1024) {
                this.showStatus('Image must be less than 5MB', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                this.compressImage(e.target.result, (compressedData) => {
                    this.currentPhoto = {
                        data: compressedData,
                        filename: `ECO_${Date.now()}.jpg`,
                        type: 'image/jpeg',
                        originalSize: file.size,
                        compressedSize: Math.round(compressedData.length * 3/4) // Approximate base64 size
                    };
                    
                    const preview = document.getElementById('photo-preview');
                    preview.src = compressedData;
                    preview.style.display = 'block';
                    
                    // Show photo remove button
                    document.getElementById('photo-remove').style.display = 'flex';
                    
                    // Show photo info
                    const photoInfo = document.getElementById('photo-info');
                    const photoSize = document.getElementById('photo-size');
                    const photoResolution = document.getElementById('photo-resolution');
                    
                    // Get image dimensions
                    const img = new Image();
                    img.onload = () => {
                        photoSize.textContent = `Size: ${this.formatBytes(this.currentPhoto.compressedSize)}`;
                        photoResolution.textContent = `Resolution: ${img.width}√ó${img.height}`;
                        photoInfo.style.display = 'block';
                    };
                    img.src = compressedData;
                });
            };
            reader.readAsDataURL(file);
        },

        // Compress image function
        compressImage(dataUrl, callback, maxWidth = 1920, maxHeight = 1080, quality = 0.7) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;

                // Calculate new dimensions while maintaining aspect ratio
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                }

                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to JPEG with specified quality
                const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                callback(compressedDataUrl);
            };
            img.src = dataUrl;
        },

        // Format bytes to human readable size
        formatBytes(bytes, decimals = 1) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        },

        // Render logbook entries
        renderLogbook() {
            const container = document.getElementById('logbook-entries');
            const emptyMessage = document.getElementById('empty-logbook');
            const observationCount = document.getElementById('observation-count');
            
            // Update observation count badge
            observationCount.textContent = `${this.observations.length} observation${this.observations.length !== 1 ? 's' : ''}`;
            
            if (this.observations.length === 0) {
                container.innerHTML = '';
                emptyMessage.style.display = 'block';
                return;
            }
            
            emptyMessage.style.display = 'none';
            
            const entriesHtml = this.observations.map(obs => `
                <div class="log-entry" data-id="${obs.id}">
                    <div class="log-header">
                        <div class="log-id">${obs.id}</div>
                        <div class="log-date"><i class="far fa-calendar"></i> ${new Date(obs.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="log-species">
                        <i class="fas fa-feather-alt"></i> ${this.escapeHtml(obs.scientificName)}
                        ${obs.commonName ? `<span style="color: var(--medium-gray); font-weight: normal;"> (${this.escapeHtml(obs.commonName)})</span>` : ''}
                    </div>
                    <div class="log-location"><i class="fas fa-map-marker-alt"></i> ${this.escapeHtml(obs.location.text)}</div>
                    <div class="log-details" id="details-${obs.id}">
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-user"></i> Observer:</strong> ${this.escapeHtml(obs.observerName)}
                        </div>
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-binoculars"></i> Observation Type:</strong> ${this.formatObservationType(obs.observationType)}
                        </div>
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-tree"></i> Habitat:</strong> ${this.capitalizeFirst(obs.habitat)}
                        </div>
                        ${obs.characteristics ? `
                            <div style="margin: 0.5rem 0;">
                                <strong><i class="fas fa-clipboard-list"></i> Characteristics:</strong> ${this.escapeHtml(obs.characteristics)}
                            </div>
                        ` : ''}
                        ${obs.equipment && obs.equipment.length > 0 ? `
                            <div style="margin: 0.5rem 0;">
                                <strong><i class="fas fa-tools"></i> Equipment:</strong> ${obs.equipment.map(eq => this.formatEquipment(eq)).join(', ')}
                            </div>
                        ` : ''}
                        ${obs.notes ? `
                            <div style="margin: 0.5rem 0;">
                                <strong><i class="fas fa-sticky-note"></i> Notes:</strong> ${this.escapeHtml(obs.notes)}
                            </div>
                        ` : ''}
                        ${obs.references ? `
                            <div style="margin: 0.5rem 0;">
                                <strong><i class="fas fa-book-open"></i> References:</strong> ${this.escapeHtml(obs.references)}
                            </div>
                        ` : ''}
                        ${obs.photo ? `
                            <div style="margin: 0.5rem 0;">
                                <strong><i class="fas fa-camera"></i> Photo:</strong> Included
                            </div>
                        ` : ''}
                        <div class="log-actions">
                            <button class="btn btn-outline btn-small edit-btn" data-id="${obs.id}">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button class="btn btn-danger btn-small delete-btn" data-id="${obs.id}">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = entriesHtml;
            
            // Add event listeners
            this.attachLogbookEventListeners();
        },

        // Attach event listeners to logbook entries
        attachLogbookEventListeners() {
            // Toggle details on entry click
            document.querySelectorAll('.log-entry').forEach(entry => {
                entry.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('edit-btn') && 
                        !e.target.classList.contains('delete-btn') &&
                        !e.target.closest('.log-actions')) {
                        const id = entry.dataset.id;
                        const details = document.getElementById(`details-${id}`);
                        details.classList.toggle('show');
                        
                        // Add animation for new entries
                        if (!entry.classList.contains('viewed')) {
                            entry.classList.add('viewed');
                        }
                    }
                });
            });
            
            // Edit buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.editObservation(btn.dataset.id);
                });
            });
            
            // Delete buttons
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteObservation(btn.dataset.id);
                });
            });
        },

        // Edit an observation
        editObservation(id) {
            const observation = this.observations.find(obs => obs.id === id);
            if (!observation) return;

            // Parse date and time
            const dateTime = new Date(observation.timestamp);
            const dateStr = dateTime.toISOString().split('T')[0];
            const timeStr = dateTime.toTimeString().slice(0, 5);

            // Populate form
            document.getElementById('observation-date').value = dateStr;
            document.getElementById('observation-time').value = timeStr;
            document.getElementById('observer-name').value = observation.observerName;
            document.getElementById('scientific-name').value = observation.scientificName;
            document.getElementById('common-name').value = observation.commonName;
            document.getElementById('location').value = observation.location.text;
            document.getElementById('habitat').value = observation.habitat;
            document.getElementById('observation-type').value = observation.observationType;
            document.getElementById('characteristics').value = observation.characteristics;
            document.getElementById('notes').value = observation.notes;
            document.getElementById('references').value = observation.references;

            // Equipment checkboxes
            document.querySelectorAll('input[name="equipment"]').forEach(cb => {
                cb.checked = false;
                if (observation.equipment) {
                    const eqValue = cb.value;
                    observation.equipment.forEach(eq => {
                        if (eq.startsWith('other:') && eqValue === 'other-equipment') {
                            cb.checked = true;
                            document.getElementById('other-equipment').value = eq.substring(6);
                            document.getElementById('other-equipment').style.display = 'block';
                        } else if (eq === eqValue) {
                            cb.checked = true;
                        }
                    });
                }
            });

            // Photo
            if (observation.photo) {
                this.currentPhoto = observation.photo;
                const preview = document.getElementById('photo-preview');
                preview.src = observation.photo.data;
                preview.style.display = 'block';
                
                // Show photo remove button
                document.getElementById('photo-remove').style.display = 'flex';
                
                // Show photo info
                const photoInfo = document.getElementById('photo-info');
                const photoSize = document.getElementById('photo-size');
                photoSize.textContent = `Size: ${this.formatBytes(observation.photo.compressedSize || observation.photo.data.length * 3/4)}`;
                photoInfo.style.display = 'block';
            }

            // Change record button to update
            const recordBtn = document.getElementById('record-btn');
            recordBtn.innerHTML = '<i class="fas fa-save"></i> Update Observation';
            recordBtn.dataset.editingId = id;
            recordBtn.onclick = () => this.handleUpdateObservation(id);
            
            // Switch to record tab
            this.switchTab('record');
            document.getElementById('observer-name').focus();
        },

        // Handle updating an observation
        handleUpdateObservation(id) {
            // Get all form values (same as recording)
            const date = document.getElementById('observation-date').value;
            const time = document.getElementById('observation-time').value;
            const observerName = document.getElementById('observer-name').value.trim();
            const scientificName = document.getElementById('scientific-name').value.trim();
            const commonName = document.getElementById('common-name').value.trim();
            const location = document.getElementById('location').value.trim();
            const habitat = document.getElementById('habitat').value;
            const observationType = document.getElementById('observation-type').value;
            const characteristics = document.getElementById('characteristics').value.trim();
            const notes = document.getElementById('notes').value.trim();
            const references = document.getElementById('references').value.trim();

            // Get equipment used
            const equipment = [];
            document.querySelectorAll('input[name="equipment"]:checked').forEach(cb => {
                equipment.push(cb.value);
            });
            
            // Add other equipment if specified
            const otherEquipment = document.getElementById('other-equipment').value.trim();
            if (otherEquipment && equipment.includes('other-equipment')) {
                equipment[equipment.indexOf('other-equipment')] = `other: ${otherEquipment}`;
            }

            // Validation
            if (!date || !time || !observerName || !scientificName || !location || !habitat || !observationType) {
                this.showStatus('Please fill in all required fields', 'error');
                return;
            }

            const updatedData = {
                timestamp: new Date(date + 'T' + time).toISOString(),
                observerName,
                scientificName,
                commonName,
                location: {
                    text: location,
                    coordinates: this.observations.find(obs => obs.id === id)?.location.coordinates || null,
                    accuracy: this.observations.find(obs => obs.id === id)?.location.accuracy || null
                },
                habitat,
                observationType,
                characteristics,
                notes,
                equipment,
                references,
                photo: this.currentPhoto
            };

            if (this.updateObservation(id, updatedData)) {
                this.showStatus('Observation updated successfully!', 'success');
                
                // Reset form and button
                this.resetForm();
            }
        },

        // Handle export generation
        handleExport() {
            const format = document.querySelector('input[name="export-format"]:checked').value;
            const dateFrom = document.getElementById('date-from').value;
            const dateTo = document.getElementById('date-to').value;
            const enableBatch = document.getElementById('enable-batch-selection').checked;
            
            // Get selected observation IDs if batch selection is enabled
            const selectedIds = enableBatch && this.selectedObservations.size > 0 ? this.selectedObservations : null;
            
            const filteredObservations = this.getFilteredObservations(dateFrom, dateTo, selectedIds);
            
            if (filteredObservations.length === 0) {
                this.showStatus('No observations found for the selected criteria', 'error', 'export');
                return;
            }
            
            if (format === 'csv') {
                this.exportToCSV(filteredObservations, dateFrom, dateTo, selectedIds);
            } else {
                this.exportToPDF(filteredObservations, dateFrom, dateTo, selectedIds);
            }
        },

        // Export to CSV with all fields and metadata
        exportToCSV(observations, dateFrom, dateTo, selectedIds) {
            const headers = [
                'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
                'Latitude', 'Longitude', 'Habitat', 'Observation Type',
                'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
            ];
            
            // Create metadata header
            const metadata = [
                `Export Metadata:`,
                `Exported: ${new Date().toLocaleString()}`,
                `Total Observations: ${observations.length}`,
                `Date Range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`,
                `Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`,
                `Exported by: ${observations[0]?.observerName || 'EcoLens User'}`,
                `App Version: 1.0`,
                ``
            ];
            
            const rows = observations.map(obs => [
                `"${this.sanitizeCSVValue(obs.id)}"`,
                `"${new Date(obs.timestamp).toLocaleString()}"`,
                `"${this.sanitizeCSVValue(obs.observerName)}"`,
                `"${this.sanitizeCSVValue(obs.scientificName)}"`,
                `"${this.sanitizeCSVValue(obs.commonName)}"`,
                `"${this.sanitizeCSVValue(obs.location.text)}"`,
                obs.location.coordinates?.lat || '',
                obs.location.coordinates?.lng || '',
                `"${this.sanitizeCSVValue(obs.habitat)}"`,
                `"${this.sanitizeCSVValue(obs.observationType)}"`,
                `"${this.sanitizeCSVValue(obs.characteristics || '')}"`,
                `"${this.sanitizeCSVValue((obs.equipment || []).join('; '))}"`,
                `"${this.sanitizeCSVValue(obs.references || '')}"`,
                `"${this.sanitizeCSVValue(obs.notes || '')}"`,
                obs.photo ? 'Yes' : 'No'
            ]);
            
            const csvContent = [
                ...metadata,
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const filename = selectedIds ? 
                `EcoLens_Selected_Export_${new Date().toISOString().slice(0,10)}.csv` :
                `EcoLens_Export_${new Date().toISOString().slice(0,10)}.csv`;
            
            this.showExportDownload(url, filename);
            this.showStatus(`Exported ${observations.length} observations to CSV`, 'success', 'export');
        },

        // Export to PDF
        exportToPDF(observations, dateFrom, dateTo, selectedIds) {
            if (this.isGeneratingPDF) {
                this.showStatus('PDF generation already in progress', 'warning', 'export');
                return;
            }

            this.isGeneratingPDF = true;
            const exportBtn = document.getElementById('generate-export');
            const originalText = exportBtn.textContent;
            exportBtn.innerHTML = '<span class="loading"></span> Generating PDF...';
            exportBtn.disabled = true;

            // Show progress UI
            const progressUI = document.getElementById('pdf-progress');
            const progressBar = document.getElementById('pdf-progress-bar');
            const statusText = document.getElementById('pdf-status-text');
            const currentAction = document.getElementById('pdf-current-action');
            
            progressUI.style.display = 'block';
            progressBar.value = 0;
            statusText.textContent = 'Preparing PDF document...';
            currentAction.textContent = '';

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            const margin = 15;
            const pageWidth = doc.internal.pageSize.width;
            const pageHeight = doc.internal.pageSize.height;
            const contentWidth = pageWidth - (margin * 2);
            let y = margin;
            let currentPage = 1;
            const totalObservations = observations.length;
            let processedObservations = 0;

            // Improved PDF text wrapping with isolated column handling
            const addWrappedText = (text, x, startY, maxWidth, lineHeight = 5, maxLines = null) => {
                if (!text || text.trim() === '') return startY;
                
                const lines = doc.splitTextToSize(text, maxWidth);
                const linesToShow = maxLines ? lines.slice(0, maxLines) : lines;
                
                // Check if we have enough space
                const requiredSpace = linesToShow.length * lineHeight;
                if (y + requiredSpace > pageHeight - margin) {
                    doc.addPage();
                    currentPage++;
                    y = margin;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                    y += 5;
                    
                    doc.setDrawColor(200);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                    startY = y;
                }
                
                linesToShow.forEach((line, index) => {
                    doc.text(line, x, startY + (index * lineHeight));
                });
                
                const finalY = startY + (linesToShow.length * lineHeight);
                
                // Add ellipsis if text was truncated
                if (maxLines && lines.length > maxLines) {
                    doc.setFontSize(8);
                    doc.setTextColor(120);
                    doc.text('... (continued)', x, finalY);
                    return finalY + 4;
                }
                
                return finalY;
            };

            // Helper function to check if we need a new page
            const checkPageSpace = (requiredSpace) => {
                if (y + requiredSpace > pageHeight - margin) {
                    doc.addPage();
                    currentPage++;
                    y = margin;
                    
                    // Add page header
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                    y += 5;
                    
                    // Add page separator
                    doc.setDrawColor(200);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                    return true;
                }
                return false;
            };

            // Update progress
            const updateProgress = (step, action) => {
                const progress = Math.round((processedObservations / totalObservations) * 100);
                progressBar.value = progress;
                currentAction.textContent = action;
                
                if (step === 'observation') {
                    processedObservations++;
                    statusText.textContent = `Processing observation ${processedObservations} of ${totalObservations}`;
                }
            };

            // Generate PDF asynchronously to show progress
            setTimeout(async () => {
                try {
                    // Cover page with metadata
                    updateProgress('cover', 'Creating cover page...');
                    
                    doc.setFontSize(24);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(40, 100, 60);
                    doc.text('ECOLENS FIELD LOG', pageWidth / 2, 60, { align: 'center' });
                    
                    doc.setFontSize(16);
                    doc.setTextColor(80);
                    doc.text('Field Observation Report', pageWidth / 2, 75, { align: 'center' });
                    
                    // Report metadata
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'normal');
                    y = 100;
                    
                    let dateRangeText = 'All observations';
                    if (dateFrom || dateTo) {
                        dateRangeText = `From: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
                    }
                    
                    doc.text(`Report Period: ${dateRangeText}`, pageWidth / 2, y, { align: 'center' });
                    y += 10;
                    doc.text(`Total Observations: ${totalObservations}`, pageWidth / 2, y, { align: 'center' });
                    y += 10;
                    doc.text(`Exported: ${new Date().toLocaleString()}`, pageWidth / 2, y, { align: 'center' });
                    y += 10;
                    doc.text(`Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`, pageWidth / 2, y, { align: 'center' });
                    y += 10;
                    doc.text(`Exported by: ${observations[0]?.observerName || 'EcoLens User'}`, pageWidth / 2, y, { align: 'center' });
                    y += 20;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text('This report contains detailed field observations including photos,', pageWidth / 2, y, { align: 'center' });
                    y += 5;
                    doc.text('location data, and comprehensive metadata for each record.', pageWidth / 2, y, { align: 'center' });
                    
                    // Table of contents
                    doc.addPage();
                    currentPage++;
                    y = margin;
                    
                    // Add page header
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                    y += 5;
                    
                    // Add page separator
                    doc.setDrawColor(200);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                    
                    updateProgress('toc', 'Creating table of contents...');
                    
                    // Table of contents header
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(40, 40, 40);
                    doc.text('Table of Contents', margin, y);
                    y += 8;
                    
                    // Add underline
                    doc.setDrawColor(100, 150, 100);
                    doc.line(margin, y, margin + 50, y);
                    y += 10;
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(60);
                    
                    y += 10;
                    observations.forEach((obs, index) => {
                        // Check space for each TOC entry
                        checkPageSpace(7);
                        const entry = `${index + 1}. ${obs.scientificName} (${obs.id})`;
                        doc.text(entry, margin, y);
                        y += 7;
                    });
                    
                    // Process each observation
                    for (let i = 0; i < observations.length; i++) {
                        const obs = observations[i];
                        
                        // Add new page for each observation
                        doc.addPage();
                        currentPage++;
                        y = margin;
                        
                        // Add page header
                        doc.setFontSize(10);
                        doc.setTextColor(100);
                        doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                        y += 5;
                        
                        // Add page separator
                        doc.setDrawColor(200);
                        doc.line(margin, y, pageWidth - margin, y);
                        y += 10;
                        
                        updateProgress('observation', `Adding observation: ${obs.scientificName}`);
                        
                        // Observation header
                        checkPageSpace(20); // Space for header
                        doc.setFontSize(14);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(40, 40, 40);
                        doc.text(`Observation ${i + 1}: ${obs.id}`, margin, y);
                        y += 10;
                        
                        // Observation details in two columns
                        const col1X = margin;
                        const col2X = margin + (contentWidth / 2) + 5;
                        const columnWidth = (contentWidth / 2) - 5;
                        
                        // Start columns at same y position
                        let col1Y = y;
                        let col2Y = y;
                        
                        // COLUMN 1: Basic Information
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'bold');
                        doc.text('BASIC INFORMATION', col1X, col1Y);
                        col1Y += 7; // Space after heading
                        doc.setFont('helvetica', 'normal');
                        
                        // Add key-value pairs in column 1
                        const col1Items = [
                            { key: 'Date/Time', value: new Date(obs.timestamp).toLocaleString() },
                            { key: 'Observer', value: obs.observerName },
                            { key: 'Scientific Name', value: obs.scientificName },
                            { key: 'Common Name', value: obs.commonName || 'Not specified' },
                            { key: 'Habitat', value: this.capitalizeFirst(obs.habitat) },
                            { key: 'Observation Type', value: this.formatObservationType(obs.observationType) }
                        ];
                        
                        col1Items.forEach(item => {
                            doc.setFont('helvetica', 'bold');
                            const keyText = `${item.key}: `;
                            const keyWidth = doc.getTextWidth(keyText);
                            doc.text(keyText, col1X, col1Y);
                            
                            doc.setFont('helvetica', 'normal');
                            col1Y = addWrappedText(item.value, col1X + keyWidth, col1Y, columnWidth - keyWidth, 5, 8);
                            col1Y += 2;
                        });
                        
                        // COLUMN 2: Location & Equipment
                        doc.setFont('helvetica', 'bold');
                        doc.text('LOCATION & EQUIPMENT', col2X, col2Y);
                        col2Y += 7; // Space after heading
                        doc.setFont('helvetica', 'normal');
                        
                        // Add key-value pairs in column 2
                        const col2Items = [];
                        
                        // Location text
                        col2Items.push({ key: 'Location', value: obs.location.text });
                        
                        // Coordinates if available
                        if (obs.location.coordinates) {
                            const coords = `Lat: ${obs.location.coordinates.lat.toFixed(5)}, Lng: ${obs.location.coordinates.lng.toFixed(5)}`;
                            col2Items.push({ key: 'Coordinates', value: coords });
                        }
                        
                        // Accuracy if available
                        if (obs.location.accuracy) {
                            col2Items.push({ key: 'Accuracy', value: `¬±${Math.round(obs.location.accuracy)} meters` });
                        }
                        
                        // Equipment if available
                        if (obs.equipment && obs.equipment.length > 0) {
                            const equipmentText = obs.equipment.map(eq => this.formatEquipment(eq)).join(', ');
                            col2Items.push({ key: 'Equipment Used', value: equipmentText });
                        }
                        
                        // References if available
                        if (obs.references) {
                            col2Items.push({ key: 'References', value: obs.references });
                        }
                        
                        col2Items.forEach(item => {
                            doc.setFont('helvetica', 'bold');
                            const keyText = `${item.key}: `;
                            const keyWidth = doc.getTextWidth(keyText);
                            doc.text(keyText, col2X, col2Y);
                            
                            doc.setFont('helvetica', 'normal');
                            col2Y = addWrappedText(item.value, col2X + keyWidth, col2Y, columnWidth - keyWidth, 5, 8);
                            col2Y += 2;
                        });
                        
                        // Set y to the bottom of the tallest column
                        y = Math.max(col1Y, col2Y) + 15;
                        
                        // Characteristics section
                        if (obs.characteristics) {
                            // Add section spacing
                            y += 5;
                            checkPageSpace(15);
                            
                            // Section header
                            doc.setFontSize(12);
                            doc.setFont('helvetica', 'bold');
                            doc.setTextColor(40, 40, 40);
                            doc.text('DESCRIPTION / CHARACTERISTICS', margin, y);
                            y += 8;
                            
                            // Add underline
                            doc.setDrawColor(100, 150, 100);
                            doc.line(margin, y, margin + 50, y);
                            y += 10;
                            
                            doc.setFontSize(10);
                            doc.setFont('helvetica', 'normal');
                            doc.setTextColor(60);
                            
                            y = addWrappedText(obs.characteristics, margin, y, contentWidth, 5);
                            y += 10;
                        }
                        
                        // Notes section
                        if (obs.notes) {
                            // Add section spacing
                            y += 5;
                            checkPageSpace(15);
                            
                            // Section header
                            doc.setFontSize(12);
                            doc.setFont('helvetica', 'bold');
                            doc.setTextColor(40, 40, 40);
                            doc.text('ADDITIONAL NOTES', margin, y);
                            y += 8;
                            
                            // Add underline
                            doc.setDrawColor(100, 150, 100);
                            doc.line(margin, y, margin + 50, y);
                            y += 10;
                            
                            doc.setFontSize(10);
                            doc.setFont('helvetica', 'normal');
                            doc.setTextColor(60);
                            
                            y = addWrappedText(obs.notes, margin, y, contentWidth, 5);
                            y += 10;
                        }
                        
                        // Photo section
                        if (obs.photo && obs.photo.data) {
                            // Add section spacing
                            y += 5;
                            checkPageSpace(15);
                            
                            // Section header
                            doc.setFontSize(12);
                            doc.setFont('helvetica', 'bold');
                            doc.setTextColor(40, 40, 40);
                            doc.text('PHOTO / EVIDENCE', margin, y);
                            y += 8;
                            
                            // Add underline
                            doc.setDrawColor(100, 150, 100);
                            doc.line(margin, y, margin + 50, y);
                            y += 10;
                            
                            try {
                                updateProgress('photo', `Adding photo for: ${obs.scientificName}`);
                                
                                // Check if we have enough space for the photo (80mm minimum)
                                checkPageSpace(80);
                                
                                // Add photo caption
                                doc.setFontSize(9);
                                doc.setTextColor(80);
                                doc.text('Observation Photo:', margin, y);
                                y += 5;
                                
                                // Add photo with fixed aspect ratio
                                const maxImgWidth = contentWidth;
                                const maxImgHeight = 80; // Max height for photos
                                
                                // Convert base64 to image object
                                const img = new Image();
                                await new Promise((resolve, reject) => {
                                    img.onload = resolve;
                                    img.onerror = reject;
                                    img.src = obs.photo.data;
                                });
                                
                                // Calculate dimensions maintaining aspect ratio
                                let imgWidth = img.width;
                                let imgHeight = img.height;
                                const aspectRatio = imgWidth / imgHeight;
                                
                                if (imgWidth > maxImgWidth) {
                                    imgWidth = maxImgWidth;
                                    imgHeight = imgWidth / aspectRatio;
                                }
                                
                                if (imgHeight > maxImgHeight) {
                                    imgHeight = maxImgHeight;
                                    imgWidth = imgHeight * aspectRatio;
                                }
                                
                                // Center the image
                                const imgX = margin + (contentWidth - imgWidth) / 2;
                                
                                // Add image to PDF
                                doc.addImage(
                                    img,
                                    'JPEG',
                                    imgX,
                                    y,
                                    imgWidth,
                                    imgHeight
                                );
                                
                                y += imgHeight + 10;
                                
                                // Add photo metadata
                                doc.setFontSize(8);
                                doc.setTextColor(100);
                                const imgMetadata = `File: ${obs.photo.filename || 'photo.jpg'} | Included in record`;
                                doc.text(imgMetadata, margin, y);
                                y += 6;
                                
                            } catch (error) {
                                console.error('Error adding photo to PDF:', error);
                                doc.setFontSize(9);
                                doc.setTextColor(150, 0, 0);
                                doc.text('Photo could not be included in PDF (format issue)', margin, y);
                                y += 10;
                            }
                        }
                        
                        // Metadata footer
                        doc.setFontSize(8);
                        doc.setTextColor(120);
                        doc.setFont('helvetica', 'italic');
                        
                        // Check space for metadata
                        checkPageSpace(20);
                        
                        const metadataLines = [
                            `Record ID: ${obs.id}`,
                            `Created: ${new Date(obs.timestamp).toLocaleString()}`,
                            `Last Modified: ${new Date(obs.metadata.lastModified).toLocaleString()}`,
                            `Device: ${obs.metadata.deviceInfo.substring(0, 40)}...`
                        ];
                        
                        metadataLines.forEach(line => {
                            doc.text(line, margin, y);
                            y += 4;
                        });
                        
                        y += 10;
                        
                        // Add page separator if not last observation
                        if (i < observations.length - 1) {
                            checkPageSpace(15);
                            doc.setDrawColor(200);
                            doc.setLineWidth(0.5);
                            doc.line(margin, y, pageWidth - margin, y);
                            y += 15;
                        }
                    }
                    
                    // Final page - summary
                    doc.addPage();
                    currentPage++;
                    y = margin;
                    
                    // Add page header
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                    y += 5;
                    
                    // Add page separator
                    doc.setDrawColor(200);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                    
                    updateProgress('summary', 'Adding summary page...');
                    
                    // Summary header
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(40, 40, 40);
                    doc.text('REPORT SUMMARY', margin, y);
                    y += 8;
                    
                    // Add underline
                    doc.setDrawColor(100, 150, 100);
                    doc.line(margin, y, margin + 50, y);
                    y += 10;
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(60);
                    
                    y += 10;
                    
                    // Export metadata
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.text('Export Information:', margin, y);
                    y += 10;
                    
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(10);
                    
                    const exportInfo = [
                        `Exported: ${new Date().toLocaleString()}`,
                        `Total Observations: ${totalObservations}`,
                        `Date Range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`,
                        `Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`,
                        `Exported by: ${observations[0]?.observerName || 'EcoLens User'}`
                    ];
                    
                    exportInfo.forEach(info => {
                        doc.text(info, margin, y);
                        y += 5;
                    });
                    
                    y += 10;
                    
                    // Statistics
                    doc.setFont('helvetica', 'bold');
                    doc.text('Statistics:', margin, y);
                    y += 10;
                    
                    doc.setFont('helvetica', 'normal');
                    
                    // Count by habitat
                    const habitatCount = {};
                    observations.forEach(obs => {
                        habitatCount[obs.habitat] = (habitatCount[obs.habitat] || 0) + 1;
                    });
                    
                    doc.text('Observations by Habitat Type:', margin, y);
                    y += 7;
                    
                    Object.entries(habitatCount).forEach(([habitat, count]) => {
                        checkPageSpace(5);
                        doc.text(`  ${this.capitalizeFirst(habitat)}: ${count}`, margin + 5, y);
                        y += 5;
                    });
                    
                    y += 5;
                    
                    // Count by observation type
                    const typeCount = {};
                    observations.forEach(obs => {
                        typeCount[obs.observationType] = (typeCount[obs.observationType] || 0) + 1;
                    });
                    
                    doc.text('Observations by Type:', margin, y);
                    y += 7;
                    
                    Object.entries(typeCount).forEach(([type, count]) => {
                        checkPageSpace(5);
                        doc.text(`  ${this.formatObservationType(type)}: ${count}`, margin + 5, y);
                        y += 5;
                    });
                    
                    y += 10;
                    
                    // Photos summary
                    const photoCount = observations.filter(obs => obs.photo).length;
                    doc.text(`Total photos included: ${photoCount}`, margin, y);
                    y += 7;
                    
                    // Date range
                    const dates = observations.map(obs => new Date(obs.timestamp)).sort((a, b) => a - b);
                    if (dates.length > 0) {
                        const firstDate = dates[0].toLocaleDateString();
                        const lastDate = dates[dates.length - 1].toLocaleDateString();
                        doc.text(`Date range: ${firstDate} to ${lastDate}`, margin, y);
                        y += 7;
                    }
                    
                    // Final message
                    y += 10;
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor(100);
                    doc.text('--- End of Report ---', pageWidth / 2, y, { align: 'center' });
                    
                    // Save PDF
                    updateProgress('save', 'Finalizing PDF...');
                    
                    const filename = selectedIds ?
                        `EcoLens_Selected_Report_${new Date().toISOString().slice(0,10)}.pdf` :
                        `EcoLens_Field_Log_${new Date().toISOString().slice(0,10)}.pdf`;
                    
                    const pdfBlob = doc.output('blob');
                    const pdfUrl = URL.createObjectURL(pdfBlob);
                    
                    // Complete progress
                    progressBar.value = 100;
                    statusText.textContent = 'PDF generation complete!';
                    currentAction.textContent = '';
                    
                    setTimeout(() => {
                        this.showExportDownload(pdfUrl, filename);
                        this.showStatus(`Successfully exported ${observations.length} observations to PDF`, 'success', 'export');
                        
                        // Reset UI
                        exportBtn.innerHTML = '<i class="fas fa-file-export"></i> Generate Export';
                        exportBtn.disabled = false;
                        this.isGeneratingPDF = false;
                        
                        // Hide progress after 3 seconds
                        setTimeout(() => {
                            progressUI.style.display = 'none';
                        }, 3000);
                    }, 500);
                    
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    this.showStatus(`Error generating PDF: ${error.message}`, 'error', 'export');
                    
                    // Reset UI
                    exportBtn.innerHTML = '<i class="fas fa-file-export"></i> Generate Export';
                    exportBtn.disabled = false;
                    this.isGeneratingPDF = false;
                    progressUI.style.display = 'none';
                }
            }, 100);
        },

        // Show export download link
        showExportDownload(url, filename) {
            const downloadLink = document.getElementById('download-link');
            downloadLink.href = url;
            downloadLink.download = filename;
            document.getElementById('export-download').style.display = 'block';
            downloadLink.scrollIntoView({ behavior: 'smooth' });
        },

        // Show status message
        showStatus(message, type = 'info', panel = 'record') {
            const statusEl = document.getElementById(`${panel}-status`);
            if (!statusEl) {
                console.error(`Status element not found for panel: ${panel}`);
                return;
            }
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        },

        // Show location status
        showLocationStatus(message, type = 'info') {
            const statusEl = document.getElementById('location-status');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            if (type === 'error') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        },

        // Update date inputs with current date
        updateDateInputs() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('date-from').value = today;
            document.getElementById('date-to').value = today;
            document.getElementById('date-from').max = today;
            document.getElementById('date-to').max = today;
        },

        // Utility: Format observation type for display
        formatObservationType(type) {
            const typeMap = {
                'direct': 'Direct sighting',
                'scat': 'Scat/droppings',
                'track': 'Track/footprint',
                'call': 'Call/sound',
                'nest': 'Nest/den',
                'roadkill': 'Roadkill',
                'feather': 'Feather',
                'bone': 'Bone/skull',
                'other': 'Other evidence'
            };
            return typeMap[type] || this.capitalizeFirst(type);
        },

        // Utility: Format equipment for display
        formatEquipment(equipment) {
            const eqMap = {
                'binoculars': 'Binoculars',
                'camera': 'Camera',
                'hand-lens': 'Hand lens',
                'gps': 'GPS',
                'microscope': 'Microscope',
                'hair-tube': 'Hair tube',
                'pitfall-trap': 'Pitfall trap',
                'camera-trap': 'Camera trap',
                'other-equipment': 'Other'
            };
            
            if (equipment.startsWith('other: ')) {
                return equipment.substring(7);
            }
            
            return eqMap[equipment] || this.capitalizeFirst(equipment);
        },

        // Utility: Escape HTML to prevent XSS
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Utility: Capitalize first letter
        capitalizeFirst(string) {
            return string ? string.charAt(0).toUpperCase() + string.slice(1) : '';
        }
    };

    // Initialize the app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        EcoLens.init();
    });

    // Add offline detection
    window.addEventListener('online', () => {
        console.log('App is online');
        EcoLens.showStatus('You are back online', 'success');
    });

    window.addEventListener('offline', () => {
        console.log('App is offline - data saved locally');
        EcoLens.showStatus('You are offline. Observations are saved locally.', 'warning');
    });

    // Check if localStorage is available
    try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
    } catch (e) {
        console.error('localStorage is not available:', e);
        EcoLens.showStatus('Warning: Local storage is disabled. Data will not be saved.', 'error');
    }

    // Add touch support for mobile devices
    document.addEventListener('touchstart', function() {}, {passive: true});
</script>
</body>
</html>
